<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石 - Gao Haojun</title><link rel="manifest" href="/Blog/manifest.json"><meta name="application-name" content="Gao Haojun"><meta name="msapplication-TileImage" content="/img/favicon.jpeg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Gao Haojun"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在人工智能的浪潮中，我们正见证一个深刻的范式转变：智能体（AI Agents）不再仅仅是响应指令的瞬时执行体，而是逐渐成为能够与环境持续交互、从经验中学习、并维系长期一致性的自主实体**。这一转变的核心驱动力，在于记忆**：它已从模型的附属功能，跃升为智能体实现长周期推理、持续适应与复杂决策的认知基石。 **然而，伴随研究的快速扩张，智能体记忆领域却呈现出一种繁荣下的混沌。**大量创新在动机、实现"><meta property="og:type" content="blog"><meta property="og:title" content="Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石"><meta property="og:url" content="http://vincentgaohj.github.io/Blog/2026/01/19/Agent%E6%97%B6%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E5%B7%A5%E7%A8%8B-%E4%BB%8E%E7%9E%AC%E6%97%B6%E7%94%9F%E6%88%90%E5%88%B0%E6%8C%81%E7%BB%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AE%A4%E7%9F%A5%E5%9F%BA%E7%9F%B3/"><meta property="og:site_name" content="Gao Haojun"><meta property="og:description" content="在人工智能的浪潮中，我们正见证一个深刻的范式转变：智能体（AI Agents）不再仅仅是响应指令的瞬时执行体，而是逐渐成为能够与环境持续交互、从经验中学习、并维系长期一致性的自主实体**。这一转变的核心驱动力，在于记忆**：它已从模型的附属功能，跃升为智能体实现长周期推理、持续适应与复杂决策的认知基石。 **然而，伴随研究的快速扩张，智能体记忆领域却呈现出一种繁荣下的混沌。**大量创新在动机、实现"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://vincentgaohj.github.io/Blog/gallery/AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4/big5.png"><meta property="article:published_time" content="2026-01-19T06:22:21.000Z"><meta property="article:modified_time" content="2026-01-19T06:32:58.247Z"><meta property="article:author" content="Haojun(Vincent) Gao"><meta property="article:tag" content="AWS"><meta property="article:tag" content="Certified"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://vincentgaohj.github.io/Blog/gallery/AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4/big5.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://vincentgaohj.github.io/Blog/2026/01/19/Agent%E6%97%B6%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E5%B7%A5%E7%A8%8B-%E4%BB%8E%E7%9E%AC%E6%97%B6%E7%94%9F%E6%88%90%E5%88%B0%E6%8C%81%E7%BB%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AE%A4%E7%9F%A5%E5%9F%BA%E7%9F%B3/"},"headline":"Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石","image":["http://vincentgaohj.github.io/Blog/gallery/AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4/big5.png"],"datePublished":"2026-01-19T06:22:21.000Z","dateModified":"2026-01-19T06:32:58.247Z","author":{"@type":"Person","name":"Haojun(Vincent) Gao"},"publisher":{"@type":"Organization","name":"Gao Haojun","logo":{"@type":"ImageObject","url":"http://vincentgaohj.github.io/img/logo.jpg"}},"description":"在人工智能的浪潮中，我们正见证一个深刻的范式转变：智能体（AI Agents）不再仅仅是响应指令的瞬时执行体，而是逐渐成为能够与环境持续交互、从经验中学习、并维系长期一致性的自主实体**。这一转变的核心驱动力，在于记忆**：它已从模型的附属功能，跃升为智能体实现长周期推理、持续适应与复杂决策的认知基石。 **然而，伴随研究的快速扩张，智能体记忆领域却呈现出一种繁荣下的混沌。**大量创新在动机、实现"}</script><link rel="canonical" href="http://vincentgaohj.github.io/Blog/2026/01/19/Agent%E6%97%B6%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E5%B7%A5%E7%A8%8B-%E4%BB%8E%E7%9E%AC%E6%97%B6%E7%94%9F%E6%88%90%E5%88%B0%E6%8C%81%E7%BB%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AE%A4%E7%9F%A5%E5%9F%BA%E7%9F%B3/"><link rel="icon" href="/Blog/img/favicon.jpeg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/Blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?192470116504c325dfc73c99f66225ed";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-N6S845NT1J" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-N6S845NT1J');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 8.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/Blog/"><img src="/Blog/img/logo.jpg" alt="Gao Haojun" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/Blog/">Home</a><a class="navbar-item" href="/Blog/archives">Archives</a><a class="navbar-item" href="/Blog/categories">Categories</a><a class="navbar-item" href="/Blog/tags">Tags</a><a class="navbar-item" href="/Blog/about">About</a><a class="navbar-item" href="/Blog/links">Links</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/VincentGaoHJ"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/Blog/gallery/AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4/big5.png" alt="Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2026-01-19T06:22:21.000Z" title="2026/1/19 14:22:21">2026-01-19</time></span><span class="level-item"><a class="link-muted" href="/Blog/categories/AI/">AI</a><span> / </span><a class="link-muted" href="/Blog/categories/AI/Research/">Research</a></span><span class="level-item">4 hours read (About 38894 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石</h1><div class="content"><p>在人工智能的浪潮中，我们正见证一个深刻的范式转变：智能体（AI Agents）不再仅仅是响应指令的瞬时执行体，而是逐渐成为能够与环境持续交互、从经验中学习、并维系长期一致性的自主实体**。这一转变的核心驱动力，在于记忆**：它已从模型的附属功能，跃升为智能体实现长周期推理、持续适应与复杂决策的认知基石。</p>
<p>**然而，伴随研究的快速扩张，智能体记忆领域却呈现出一种繁荣下的混沌。**大量创新在动机、实现与评估上各执一词，“记忆”这一术语本身也变得日益宽泛与模糊。传统的“长期&#x2F;短期”二分法，在当今多样且动态的记忆系统面前已然力不从心。我们亟待厘清：智能体记忆的本质究竟是什么？它与大语言模型的内部记忆、检索增强生成（RAG）乃至上下文工程有何根本不同？更重要的是，我们能否找到一个统一的分析框架，以穿透技术表象的碎片化，洞察其内在的设计逻辑与演化规律？</p>
<p>2025年12月，由新加坡国立大学，中国人民大学和复旦大学等学校联合发布了一篇综述文章《Memory in the Age of AI Agents》，可以一撇其中的规律。</p>
<p>研究提出并采用一个整合性的 <strong>“形式（Forms）- 功能（Functions）- 动态（Dynamics）”分析框架</strong>，以期构建一个统一的理论透镜，用以解构与评估纷繁复杂的记忆系统设计。</p>
<blockquote>
<p>“<strong>形式（Forms）- 功能（Functions）- 动态（Dynamics）</strong>”</p>
</blockquote>
<p>在此框架下，我们得以剖析记忆的<strong>形式化表征</strong>（如令牌级、参数化与潜在记忆），其实现的<strong>认知功能</strong>（如事实记忆、经验记忆与工作记忆），以及驱动其演进的<strong>生命周期动态</strong>（包括形成、演化与检索）。</p>
<p>关于智能体如何“学会记忆”的深度探索，将直接影响我们能否构建出真正稳健、通用且持久的人工智能。记忆，正成为区分一个只会思考的模型，与一个真正能够“存在”并“成长”的智能体的关键所在。</p>
<p><strong>由此开始，揭开复杂而精妙的记忆之谜。</strong></p>
<span id="more"></span>

<p>[TOC]</p>
<p><img src="/Blog/2020/11/06/A-Comprehensive-Look-at-The%20Multi-Armed-Bandit-Problem/" alt="Memory in the Age of AI Agents: A Survey"></p>
<h2 id="一、智能体记忆亟需新的分类体系并回答关键问题"><a href="#一、智能体记忆亟需新的分类体系并回答关键问题" class="headerlink" title="一、智能体记忆亟需新的分类体系并回答关键问题"></a>一、智能体记忆亟需新的分类体系并回答关键问题</h2><p><strong>我们假设“智能体记忆系统”已确立为智能体持续认知与自主进化的核心架构，那么就有两个核心的问题需要解决：</strong></p>
<ul>
<li><p><strong>其一，既有分类体系面临认知边界危机</strong>。之前的分类方法和认知框架已经不足以描述当前的进展与研究方向。</p>
</li>
<li><p><strong>其二，核心概念体系呈现碎片化与语义稀释</strong>。众多研究虽共享“记忆”这一称谓，却在实现路径、核心目标乃至哲学假设上分道扬镳。诸如“陈述性记忆”、“情景记忆”、“参数化记忆”等术语的激增与混用，非但未能澄清本质，反而加剧了概念生态的混乱。</p>
</li>
</ul>
<p><strong>以及有一些更根本性的问题需要被解答</strong>：</p>
<p><img src="/Blog/Agent-%E6%97%B6%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E5%B7%A5%E7%A8%8B/key-question.png" alt="Key Questions"></p>
<blockquote>
<p>① 智能体记忆的定义是什么？它与大语言模型记忆、检索增强生成（RAG）、上下文工程等相关概念存在怎样的关联？</p>
<p>② <strong>形式维度</strong>：智能体记忆可采用哪些架构形式或表征形式？</p>
<p>③ <strong>功能维度</strong>：智能体为何需要记忆？记忆承担着哪些角色与功能？</p>
<p>④ <strong>动态机制维度</strong>：智能体记忆如何随时间推移实现运作、自适应与演化？</p>
<p>⑤ 推动智能体记忆研究发展的前沿方向有哪些？</p>
</blockquote>
<h4 id="LLM-智能体五类行动空间对照表"><a href="#LLM-智能体五类行动空间对照表" class="headerlink" title="LLM 智能体五类行动空间对照表"></a>LLM 智能体五类行动空间对照表</h4><table>
<thead>
<tr>
<th>行动类型</th>
<th align="left">核心定义</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>自然语言生成</strong><br />Natural-language generation</td>
<td align="left">生成符合自然语言规则的文本内容，是 LLM 智能体的基础行动类型</td>
<td>实现语言交互<br />记录推理过程<br />下达任务指令</td>
</tr>
<tr>
<td><strong>工具调用行动</strong><br />Tool invocation actions</td>
<td align="left">通过 API、接口等方式调用外部工具或服务</td>
<td>弥补 LLM 实时信息<br />精确计算<br />特定领域操作</td>
</tr>
<tr>
<td><strong>规划行动</strong><br />Planning actions</td>
<td align="left">生成任务分解方案、执行计划或子目标，输出结构化步骤</td>
<td>解决长程任务目标漂移问题<br />确保行动与最终目标对齐</td>
</tr>
<tr>
<td><strong>环境控制行动</strong><br />Environment-control actions</td>
<td align="left">直接操控物理或虚拟外部环境，是具身智能体的核心行动</td>
<td>实现智能体与环境的物理交互<br />完成空间移动<br />物体操作类任务</td>
</tr>
<tr>
<td><strong>通信行动</strong><br /> Communication actions</td>
<td align="left">智能体间 &#x2F; 智能体与人类间的结构化协作消息交互</td>
<td>支持多智能体系统协同<br />处理单智能体无法完成的复杂任务</td>
</tr>
</tbody></table>
<h4 id="Agent-Memory-vs-LLM-Memory-vs-RAG-vs-Context-Engineering"><a href="#Agent-Memory-vs-LLM-Memory-vs-RAG-vs-Context-Engineering" class="headerlink" title="Agent Memory vs. LLM Memory vs RAG vs Context Engineering"></a>Agent Memory vs. LLM Memory vs RAG vs Context Engineering</h4><table>
<thead>
<tr>
<th>对比维度</th>
<th>Agent Memory（智能体记忆）</th>
<th>LLM Memory（大语言模型记忆）</th>
<th>RAG（检索增强生成）</th>
<th>Context Engineering（上下文工程）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心目标</strong></td>
<td>支撑智能体<strong>长期环境交互与持续适应</strong>，实现 “经验积累→能力提升” 闭环</td>
<td>优化 LLM <strong>内部信息处理能力</strong>，解决长序列任务的信息保留与计算效率问题</td>
<td>提升 LLM <strong>单次生成准确性与知识时效性</strong>，缓解模型幻觉与知识过时</td>
<td>设计最优<strong>上下文输入范式</strong>，最大化 LLM 在单任务中的性能上限</td>
</tr>
<tr>
<td><strong>技术焦点</strong></td>
<td>1. 记忆全生命周期管理（<br />2. 跨任务记忆持久化<br />3. 记忆与智能体决策的耦合逻辑</td>
<td>1. 模型内部架构优化<br />2. KV 缓存管理<br />3. 长注意力机制改进</td>
<td>1. 静态知识库构建<br />2. 检索策略优化<br />3. 上下文组装与生成增强</td>
<td>1. 提示词模板设计<br />2. 上下文窗口管理<br />3. 输入信息结构化组织</td>
</tr>
<tr>
<td><strong>代表性框架 &#x2F; 方法</strong></td>
<td>MemGPT<br />MemoryBank<br />RMM<br />Agent KB<br />Zep</td>
<td>Mamba<br />RWKV<br />AutoCompressor<br />Sparseformer</td>
<td>BM25+Sentence-BERT<br />HyDE<br />Graph RAG<br />PlanRAG</td>
<td>CoT<br />Few-shot Prompting<br />Self-Consistency<br />Context Pruning</td>
</tr>
<tr>
<td><strong>与 Agent Memory 的核心关联</strong></td>
<td>——</td>
<td>纯架构优化类技术（如 Mamba）<strong>不被 Agent Memory 包含</strong>；但 KV 缓存管理可作为 Agent Memory 的<strong>工作记忆子模块</strong></td>
<td>是 Agent Memory <strong>事实记忆检索的核心技术支撑</strong>；智能体化 RAG 借鉴 Agent Memory 的自主决策能力，但缺乏记忆演化闭环</td>
<td>是 Agent Memory <strong>记忆检索后处理的关键手段</strong>（将记忆转化为适配 LLM 的上下文格式）；并且上下文压缩技术用于优化 Agent Memory 的检索输出效率</td>
</tr>
</tbody></table>
<h2 id="二、记忆的形式：词元级记忆，参数级记忆，以及隐空间记忆"><a href="#二、记忆的形式：词元级记忆，参数级记忆，以及隐空间记忆" class="headerlink" title="二、记忆的形式：词元级记忆，参数级记忆，以及隐空间记忆"></a>二、记忆的形式：词元级记忆，参数级记忆，以及隐空间记忆</h2><blockquote>
<p>智能体如何承载记忆？这并非简单的技术选型问题，而是触及了智能体认知架构的本质：记忆必须以某种物理或逻辑形式“存在”，才能被存储、演化与调用。因此，“记忆的载体形式”这一议题，核心在于探究智能体用以实例化其记忆的<strong>表征基质</strong>与<strong>存储范式</strong>。</p>
</blockquote>
<p>由于不同任务范式对记忆的持久性、访问速度、可解释性及模态兼容性提出了异构乃至矛盾的要求，智能体记忆领域并未收敛于单一的最优解，而是演化出三种根本性的载体范式：</p>
<p>三类载体范式，实则是智能体在记忆的<strong>可控性、效率与融合度</strong>三维度间做出的不同权衡。</p>
<ul>
<li>词元级记忆赋予人类最大的可控性与可解释性，代价是显式管理的开销；</li>
<li>参数级记忆追求与模型认知的深度融合与高效访问，牺牲了灵活性与透明度；</li>
<li>隐式记忆则在计算流中巧妙缓存信息，平衡了即时性与状态保持。</li>
</ul>
<table>
<thead>
<tr>
<th>记忆形式</th>
<th>存储形式</th>
<th>访问方式</th>
<th>适配任务场景</th>
</tr>
</thead>
<tbody><tr>
<td>词元级记忆</td>
<td>离散单元（文本 &#x2F; 图像块 &#x2F; 轨迹）</td>
<td>显式访问（增删 &#x2F; 检索单元）</td>
<td>对话交互<br />用户偏好存储<br />轨迹归档</td>
</tr>
<tr>
<td>参数级记忆</td>
<td>模型参数（权重 &#x2F; Adapter）</td>
<td>隐式访问（前向计算激活）</td>
<td>领域知识注入<br />角色行为固化</td>
</tr>
<tr>
<td>隐式记忆</td>
<td>内部表征（KV 缓存 &#x2F;latent 向量）</td>
<td>半隐式访问（复用 &#x2F; 转换状态）</td>
<td>长上下文推理<br />多模态整合<br />低 latency 任务</td>
</tr>
</tbody></table>
<h3 id="2-1-词元级记忆"><a href="#2-1-词元级记忆" class="headerlink" title="2.1 词元级记忆"></a>2.1 词元级记忆</h3><blockquote>
<p>词元级记忆将信息存储为持久的、离散的单元，这些单元可从外部访问和检查。这里的令牌是一个宽泛的表征概念：除了文本令牌之外，还包括视觉令牌、音频帧——任何可以在模型参数之外进行写入、检索、重组和修改的离散元素。</p>
<p>Token-level memory stores information as persistent, discrete units that are externally accessible and inspectable. The token here is a broad representational notion: beyond text tokens, it includes visual tokens, audio frames—any discrete element that can be written, retrieved, reorganized, and revised outside model parameters.</p>
</blockquote>
<p>词元级记忆将信息存储为持久的、离散的单元，这些单元可从外部访问和检查。这里的令牌是一个宽泛的表征概念：除了文本 Tokens 之外，还包括视觉 Tokens、音频帧，以及任何可以在模型参数之外进行写入、检索、重组和修改的离散元素。</p>
<h4 id="2-1-1-词元级记忆的三大类型"><a href="#2-1-1-词元级记忆的三大类型" class="headerlink" title="2.1.1 词元级记忆的三大类型"></a>2.1.1 词元级记忆的三大类型</h4><table>
<thead>
<tr>
<th>形式</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>简单记忆（1D）</td>
<td>不存在明确的单元间拓扑结构。记忆以序列或单元集合（例如片段、轨迹、块）的形式累积。</td>
</tr>
<tr>
<td>平面记忆（2D）</td>
<td>在一个平面内的结构化但单层组织：单元通过图形、树、表格等相互关联，不存在跨层关系。其结构是明确的，但不是分层的。</td>
</tr>
<tr>
<td>层次记忆（3D）</td>
<td>跨多个层结构化，层间有链接，形成体积型或分层记忆。</td>
</tr>
</tbody></table>
<h4 id="2-1-2-简单记忆（一维）"><a href="#2-1-2-简单记忆（一维）" class="headerlink" title="2.1.2 简单记忆（一维）"></a>2.1.2 简单记忆（一维）</h4><blockquote>
<p>简单记忆将信息存储为“离散单元的集合”，不会明确的建模这些单元之间的语义或关系依赖。这些单元可能包括文本块、用户档案、体验轨迹、它们相应的向量表示或多模态条目。这些单元之间的关系不会直接编码在记忆中。</p>
<p>Flat Memory stores information as accumulations of discrete units, without explicitly modeling semantic or relational dependencies among them. These units may include text chunks, user profiles, experience trajectories, their corresponding vector representations, or multi-modal entries. Relationships among these units are not encoded directly in the memory.</p>
</blockquote>
<p><strong>对话类记忆</strong></p>
<ul>
<li>存储和管理对话内容：通过存储原始对话历史或生成递归摘要来扩展上下文窗口，从而防止遗忘。MemGPT 将活跃上下文与外部存储分离，以实现“无限上下文管理”。为了提高检索精度，记忆单元的粒度和结构变得越来越多样化，并且与认知更加一致。随着对话深度的增加，记忆工程的不断发展，高级认知过程和复杂的叙事内容也可以被存储。</li>
</ul>
<p><strong>偏好类记忆</strong></p>
<ul>
<li>建模用户不断变化的品味、兴趣和决策模式，尤其是在推荐场景中，对偏好的理解是核心。与以对话为中心的记忆（其重点是保持对话的连贯性）不同，偏好记忆的核心在于识别用户的喜好和倾向。</li>
</ul>
<p><strong>档案类记忆</strong></p>
<ul>
<li>存储和维护稳定的用户档案、角色属性或长期身份信息，以便智能体在不同轮次和任务中都能表现出一致的行为。在虚拟角色扮演场景中，从小说和电视剧剧本中提取对话，通过检索记忆使模型能够保持符合角色设定的行为。</li>
<li>与静态的常识不同，经验记忆源于智能体在实际交互任务中的动态积累，包括具体观察、思维链、行动轨迹和环境反馈。</li>
</ul>
<p><strong>经验类记忆</strong></p>
<ul>
<li>对历史行为轨迹的直接存档。这种范式使智能体能够通过检索和重用过去的实例（包括成功和失败的案例）来为当前的决策提供信息。为解决原始轨迹固有的泛化能力有限这一问题，大量研究致力于将特定交互抽象为更高级别的通用经验。作为最早且最具影响力的方法之一，Reflexion 将短期记忆定义为轨迹历史，将长期记忆定义为自我反思模型产生的反馈。</li>
</ul>
<p><strong>多模态记忆</strong></p>
<ul>
<li>多模态记忆系统以从原始多模态数据（如图像、视频帧、音频片段和文本）中提取的离散的 Token 级存储信息，使智能体能够跨渠道、跨长时间跨度的经验捕获、压缩和检索知识。在可穿戴设备和以自我为中心的场景中，第一人称视频可以被转化为轻量级的语言描述。</li>
</ul>
<p>**简单记忆的主要优势在于其简单性和可扩展性：记忆的追加或删减成本极低，而相似性搜索等检索方法无需预设结构即可实现灵活访问。**这使得简单记忆适用于广泛的回忆、情节积累以及快速变化的交互历史场景。</p>
<p>**然而，由于缺乏明确的关系组织，其连贯性和相关性在很大程度上依赖于检索质量。**随着记忆规模的扩大，冗余和噪声可能会不断累积，模型可能在检索到相关单元时却无法理解它们之间的关联，这会限制组合推理、长周期规划和抽象形成的能力。</p>
<p><strong>因此，无拓扑结构的集合在广泛覆盖和轻量更新的方面表现出色，但在需要结构化推理或稳定知识组织的任务中仍然存在诸多局限性。</strong></p>
<h4 id="2-1-2-平面记忆（二维）"><a href="#2-1-2-平面记忆（二维）" class="headerlink" title="2.1.2 平面记忆（二维）"></a>2.1.2 平面记忆（二维）</h4><p><strong>平面记忆的核心在于通过建立明确的关联机制，实现从单纯的“存储”到“组织”的飞跃。</strong></p>
<blockquote>
<p>平面内存记忆在记忆单元之间引入了一种明确的组织拓扑结构，但这种结构仅限于单一的结构层内，因此简称为二维。这种拓扑结构可以是图、树、表、隐式连接结构等，其中编码了诸如邻接关系、父子顺序或语义分组等关系，这些关系被编码在一个平面内，而不涉及层级结构或跨层引用。</p>
<p>Planar Memory introduces an explicit organizational topology among memory units, but only within a single structural layer, which for short called 2D. The topology may be a graph, tree, table, implicit connection structure and so on, where relationships such as adjacency, parent–child ordering, or semantic grouping are encoded within one plane, without hierarchical levels or cross-layer references.</p>
</blockquote>
<p><strong>树结构记忆</strong></p>
<ul>
<li>树结构以层次化的方式组织信息，能够处理不同抽象层次的内容。多级结构支持从粗到细的检索，并在长上下文问答任务中表现出比扁平向量索引更好的性能。树结构能够从孤立的对话日志中推断出层次化的模式，并逐步将具体事件归纳为更高层次的概念，使智能体能够同时利用详细记忆和抽象知识。</li>
</ul>
<p><strong>图结构记忆</strong></p>
<ul>
<li>图结构因其能够捕捉复杂的关联、因果关系和时间动态，因此在二维记忆领域占据主导地位。<br>基础性工作如 Ret-LLM 将外部存储抽象为可寻址的三元组单元，使大语言模型能够与一个以关系为中心的表进行交互。</li>
</ul>
<p><strong>混合结构记忆</strong></p>
<ul>
<li>复杂任务通常需要混合架构，这些架构能够分离不同的认知功能，同时共享一个共同的记忆基底。</li>
</ul>
<p>**平面记忆通过有效建立节点之间的链接，使记忆能够利用集体协同效应，从而编码更全面的上下文知识。**此外，平面记忆支持的检索方式部仅仅是简单的迭代与轮询，而发展为了结构化的键值查找和沿边进行的关系遍历。这些能力使平面记忆在存储、组织和管理记忆方面做的更好。</p>
<p><strong>然而平面记忆也面临一个关键限制：在没有层次化的记忆机制下，所有记忆必须整合到一个单一的、整体性的模块中。随着任务场景的复杂性和多样性增加，这种冗余且扁平化的设计变得越来越难以实现稳健的性能</strong>。更重要的是，高昂的构建和搜索成本显著阻碍了这种记忆结构的实际部署。</p>
<h4 id="2-1-2-层次记忆（三维）"><a href="#2-1-2-层次记忆（三维）" class="headerlink" title="2.1.2 层次记忆（三维）"></a>2.1.2 层次记忆（三维）</h4><p><strong>层次结构支持记忆在不同抽象层次上表征：从原始观察数据，到紧凑的事件摘要，再到更高层次的主题模式。跨层次的连接进一步形成了一个多维度的记忆空间，使系统不仅能够在不同单元之间横向导航，还能在抽象层次之间垂直跨越。</strong></p>
<blockquote>
<p>层次记忆通过跨层连接将信息组织起来，从而将这些记忆塑造成一个具有体积结构的空间。</p>
<p>Hierarchical memory organizes information across layers, using inter-level connections to shape the memories into a volumetric structured space.</p>
</blockquote>
<p>层次记忆超越了简单的分层结构，旨在构建具有深度抽象能力和动态演化机制的复杂系统。研究通常采用多级图结构或受神经科学启发的某种机理，来构建一种更接近人类思维的立体记忆空间，其中信息更加丰富，记忆单元之间的连接也更加清晰和明确。</p>
<p><strong>金字塔型结构</strong></p>
<ul>
<li>信息会被逐步组织至更高的抽象层级，并采用由粗到细的方式进行查询。例如，HiAgent 通过一种以子目标为核心的层级化工作记忆来处理长程任务，既为当前活跃的子目标保留详细轨迹，同时将已完成的子目标压缩为高层摘要，以便在需要时进行选择性检索。GraphRAG 利用 Community Detection 来构建多层图索引，将实体级子图递归聚合为 Community 的摘要。</li>
</ul>
<p><strong>多层级结构</strong></p>
<ul>
<li>分层专业化，将记忆划分为不同的模块或层级，每个模块 &#x2F; 层级专注于特定的信息类型或功能。例如，将显著的长时记录与低价值的瞬时细节分离，使系统能够维持一个精简且对行为决策至关重要的记忆层。</li>
</ul>
<p>**层次记忆将记忆置于层级维度与关系维度中，使不同记忆之间能够相互作用，形成多维度的协同效应。**这种设计有助于系统编码更具整体性、上下文关联性更强的知识。</p>
<p><strong>层次记忆同时支持高效的检索能力</strong>：能够实现复杂的多路径查询，既可以在各层级内部的关系网络中进行遍历，也能够跨层级在不同抽象水平之间切换。这一能力使系统能够高精度检索与任务相关的记忆，进而实现优异的任务性能。</p>
<p>然而，该结构的复杂性与高密度的信息组织方式，给检索效率与整体效能带来了挑战。其中，如何确保所有存储的记忆始终具备语义有效性，以及如何设计系统的最优三维布局，仍是亟待解决的关键难题。</p>
<h3 id="2-2-参数化记忆"><a href="#2-2-参数化记忆" class="headerlink" title="2.2 参数化记忆"></a>2.2 参数化记忆</h3><p>与以<strong>可见且可编辑的离散单元</strong>存储信息的词元级记忆不同，参数化记忆直接将信息存储于模型参数之中。这类方法能够让模型内化并调取信息，而无需依赖外部存储介质。根据记忆相对于核心模型参数的存储位置，可以将参数化记忆划分为两种主要形式：</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>内部参数化记忆</td>
<td>记忆被编码于模型的原生参数（如权重、偏置）之中。此类方法直接调整基础模型，以此融入新知识或新行为模式。</td>
</tr>
<tr>
<td>外部参数化记忆</td>
<td>记忆被存储在额外或辅助的参数集合中，例如适配模块（adapters）、低秩适配模块（LoRA）或轻量级代理模型。这类方法通过新增参数来承载记忆，不会对模型的原生权重进行修改。</td>
</tr>
</tbody></table>
<p>这一分类体现了一项核心设计抉择：<strong>是将记忆完全融入基础模型，还是以模块化的方式附着于模型之外</strong>。</p>
<h4 id="3-2-1-内部参数化记忆"><a href="#3-2-1-内部参数化记忆" class="headerlink" title="3.2.1 内部参数化记忆"></a>3.2.1 内部参数化记忆</h4><blockquote>
<p>内部参数化记忆可将领域知识、个性化知识或下游任务所需的先验知识注入模型。记忆注入的时机可选择在预训练阶段、训练中期阶段或后训练阶段。存储于内部参数中的记忆，不会额外增加模型参数，也无需增设附加模块。</p>
</blockquote>
<p><strong>预训练阶段</strong></p>
<p>部分研究在预训练阶段引入记忆机制，是为了解决长尾的海量知识难以压缩至有限模型参数这一问题。例如，LMLM 和 HierMemLM 在预训练阶段就将用于知识检索的记忆存储于模型内部，同时将知识本身存储在外部知识库中。另有部分研究通过优化注意力机制的计算效率，提升模型的长窗口记忆能力。</p>
<p><strong>训练中期阶段</strong></p>
<p>融入来自下游任务的可泛化经验。例如，在训练中整合智能体的经验数据。还有部分研究在训练中期阶段优化大语言模型的长窗口性能与效率，使模型在记忆增强型任务中，能够凭借更长的窗口长度维持更多的短时记忆。</p>
<p><strong>后训练阶段</strong></p>
<p>在训练完成后阶段融入记忆机制，以适配下游任务。例如，让大语言模型能够记忆用户的个性化历史信息或生成风格；还有部分方案使模型能够从过往相似任务的执行成败经验中学习。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Character-LM 和 CharacterGLM</td>
<td>通过微调大语言模型，使其具备不同的性格特征</td>
</tr>
<tr>
<td>SELF-PARAM</td>
<td>借助 KL 散度蒸馏技术注入额外知识，且无需引入额外参数</td>
</tr>
<tr>
<td>Room</td>
<td>采用外部存储知识、内部存储经验的设计思路</td>
</tr>
<tr>
<td>KnowledgeEditor</td>
<td>通过修改模型内部参数，实现仅对需要编辑的目标知识进行调整</td>
</tr>
<tr>
<td>MEND</td>
<td>利用小型网络修改大模型的梯度，实现高效的知识编辑</td>
</tr>
<tr>
<td>PersonalityEdit</td>
<td>基于心理学人格理论，构建了一个大语言模型人格编辑数据集</td>
</tr>
<tr>
<td>APP</td>
<td>模型采用多训练目标设计，确保在知识编辑过程中，对相邻知识的干扰降至最低</td>
</tr>
<tr>
<td>DINM</td>
<td>提出一种模型编辑方法，能够让模型学会拒绝危险请求，同时不影响其正常功能的发挥</td>
</tr>
</tbody></table>
<p><strong>内部参数化记忆的优势在于结构简洁，不会给基础模型增加额外的推理开销与部署成本</strong>。其缺点则是内部参数的更新难度较高：存储新记忆需要对模型进行重新训练，不仅成本高昂，还容易产生遗忘旧记忆的问题。因此，内部参数化记忆更适用于大规模存储领域知识或任务先验知识，而非存储小段的个性化记忆或工作记忆。</p>
<h4 id="3-2-2-外部参数化记忆"><a href="#3-2-2-外部参数化记忆" class="headerlink" title="3.2.2 外部参数化记忆"></a>3.2.2 外部参数化记忆</h4><blockquote>
<p>将记忆以 Tokens 形式存储在大语言模型外部，会导致模型对输入窗口内符号化记忆内容的理解不够充分。与此同时，将记忆存储于大语言模型参数中则存在诸多问题，例如记忆更新难度大，且易与预训练知识产生冲突。部分研究采用了一种折中方案，即通过<strong>外部参数</strong>引入记忆，同时不改动大语言模型的原生参数。</p>
</blockquote>
<p><strong>适配模块（Adapter）</strong></p>
<p><strong>外部参数化记忆的一类常用方法，依赖于附着在冻结的基础模型上的附加模块。借助额外的参数子空间，以模块化、可逆的方式存储和检索记忆，规避了直接修改核心模型权重所带来的灾难性干扰风险。</strong></p>
<p>MLP-Memory 模型（魏等人，2025d）通过多层感知机（MLP）将检索增强生成（RAG）的知识与 Transformer 解码器进行整合。K-Adapter 模型（王等人，2021）在保持原生主干网络不变的前提下，通过训练任务专属的适配模块来注入新知识，实现了知识的持续扩展，且不会干扰预训练的特征表示。WISE 模型（王等人，2024e）进一步提出了双参数记忆架构 —— 将预训练知识与编辑后的知识分离开来，并配备了一种路由机制，能够在推理阶段动态选择要调用的参数记忆，从而缓解了终身编辑过程中的知识冲突问题。ELDER 模型（李等人，2025d）则对该方向进行了拓展，它通过维护多个低秩适配（LoRA）模块，并学习一个路由函数，基于输入语义自适应地选择或融合这些模块，提升了长期编辑场景下模型的鲁棒性与可扩展性。</p>
<p><strong>辅助大语言模型</strong></p>
<p>**架构解耦程度更高的外部参数化记忆形式，即将记忆存储在独立的模型或外部知识模块中。**MAC 通过一个 Amortization Network 将新文档中的信息压缩为 Compact Modulation，并存储至记忆库中。Retroformer 提出了一种学习范式，用于记忆过往任务执行过程中的成败经验。</p>
<p>**这种外部参数化记忆方法实现了适应性与模型稳定性的平衡。**由于记忆被编码在附加的参数模块中，因此这些模块可被自由添加、移除或替换，且不会干扰基础模型的预训练表征空间。这一特性支持模块化更新、面向特定任务的个性化定制以及可控的版本回滚，同时避免了全模型微调可能引发的灾难性遗忘或全局权重畸变问题。</p>
<p>然而，该方法同样存在局限性。外部参数模块仍需与模型的内部表征流相整合，这意味着其作用是间接的，需要通过模型的注意力机制与计算路径来传递。<strong>因此，记忆注入的效果，取决于外部参数与内部参数化知识的对接效率。</strong></p>
<h3 id="2-3-隐式记忆"><a href="#2-3-隐式记忆" class="headerlink" title="2.3 隐式记忆"></a>2.3 隐式记忆</h3><blockquote>
<p>隐式记忆是指以隐式方式承载于模型内部表征（如键值缓存、激活值、隐藏状态、隐式嵌入向量）中的记忆，而非以显式、人类可读的符号或专用参数集的形式进行存储。</p>
<p>Latent memory refers to memory that is carried implicitly in the model’s internal representations (e.g., KV cache, activations, hidden states, latent embeddings), rather than being stored as explicit, human-readable tokens or dedicated parameter sets.</p>
</blockquote>
<p>隐式记忆的优势在于不会以明文形式暴露记忆内容，且几乎不会增加推理延迟；同时，由于它能在模型自身的表征空间内保留细粒度的上下文信号，因此有望带来更显著的性能提升。</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>生成</td>
<td>隐式记忆由独立模型或模块生成，随后以可复用的内部表征形式提供给智能体</td>
</tr>
<tr>
<td>复用</td>
<td>隐式记忆直接沿用前期计算过程中产生的结果，最典型的应用是键值缓存复用（单轮对话内或多轮对话间），此外还包括传播隐藏状态的循环控制器或有状态控制器</td>
</tr>
<tr>
<td>转换</td>
<td>将已有的隐式状态转换为新的表征形式（例如通过蒸馏、池化或压缩操作），使智能体在保留核心信息的同时，降低推理延迟并减小上下文占用空间</td>
</tr>
</tbody></table>
<h4 id="2-3-1-生成"><a href="#2-3-1-生成" class="headerlink" title="2.3.1 生成"></a>2.3.1 生成</h4><blockquote>
<p><strong>现有研究的一大技术分支是是通过生成全新的隐式表征来构建记忆，而非复用或转换已有的激活值。</strong></p>
</blockquote>
<p>在该范式下，模型或辅助编码器会生成紧凑的连续状态。这些状态既可以表现为序列中的特殊符号，也可以是独立的向量，其作用是对长上下文、任务轨迹或多模态输入中的核心信息进行汇总。</p>
<p>生成的隐式摘要随后会被存储、嵌入，或作为后续推理、决策过程的条件。这一机制使系统能够突破自身原生上下文长度的限制，维持面向特定任务的中间状态，并且无需回溯原始输入，就能跨任务片段留存知识。</p>
<p><strong>尽管不同研究采用的具体形式有所差异，但其核心思路保持一致：记忆是通过习得的编码或压缩方式显式生成的，生成的隐式状态则作为可复用的记忆单元，为后续推理过程提供支撑。</strong></p>
<p>单模态与多模态方法遵循相同的核心原理：先生成紧凑的隐式表征，再将其作为记忆条目进行存储与检索。模型能够主动构建高度信息密集且适配任务需求的表征，以极低的存储开销捕捉关键动态特征、长距离依赖关系或跨模态关联信息。同时，该方法无需重复处理完整上下文，可在长时间跨度的交互任务中实现更高效的推理。</p>
<p>然而，其缺陷也同样显著。记忆的生成过程本身可能会引入信息损失或偏差，并且隐式状态在多次读写循环中可能出现偏移或误差累积的问题。此外，训练专用模块来生成隐式表征，会带来额外的计算开销、数据需求与工程实现复杂度。</p>
<h4 id="2-3-2-复用"><a href="#2-3-2-复用" class="headerlink" title="2.3.2 复用"></a>2.3.2 复用</h4><blockquote>
<p>与生成全新隐式表征的方法不同，另一类研究直接将模型的内部激活值（主要是键 - 值缓存）复用为隐式记忆。**这类方法不会对存储的键 - 值对进行转换（修改、压缩），而是将前向传播产生的原始激活值作为可复用的记忆条目。**其核心挑战在于：确定需要保留哪些键 - 值对、如何为这些键 - 值对建立索引，以及如何在长上下文或持续处理任务的需求下高效检索这些键 - 值对。</p>
</blockquote>
<p>从认知科学视角来看，格什曼等人（2025）的研究为该方向提供了理论支撑：他们将生物记忆构建为一个键 - 值系统：其中 “键” 充当检索地址，“值” 负责编码存储的内容。这一抽象模型与现代大语言模型中基于键值结构的记忆机制高度契合。</p>
<p>**复用型隐式记忆方法的核心优势在于，直接利用模型自身的内部激活值作为记忆载体。**这类研究证实，经过精心筛选的键值表征，可成为支撑长距离检索与推理任务的高效、可靠载体。</p>
<p>该方法的最大亮点是<strong>完整保留了模型内部激活值的原始信息精度</strong>，避免了因剪枝或压缩操作造成的信息损失。这使得该类方法在概念上简洁易懂，易于集成到现有模型架构中，且能高度还原模型的原生计算逻辑。然而，原始键 - 值缓存的规模会随上下文长度的增加而快速膨胀，这不仅会提升内存消耗，还可能降低检索效率。因此，复用型隐式记忆方法的实际效果，在很大程度上依赖于索引策略的设计优劣。</p>
<h4 id="2-3-3-转换"><a href="#2-3-3-转换" class="headerlink" title="2.3.3 转换"></a>2.3.3 转换</h4><blockquote>
<p>转换型隐式记忆方法的核心是对已有隐式状态进行修改、压缩或重构，而非生成全新的隐式表征，也不是直接复用原始键 - 值（KV）缓存。这类方法将 KV 缓存与隐藏层激活值视为可调整的记忆单元，通过筛选、聚合或结构转换对其进行重塑。从概念上看，转换型记忆介于生成型与复用型记忆之间：模型既不创建新的隐式表征，也不只是简单回放已存储的 KV 对。</p>
</blockquote>
<p>现有研究的一大技术分支聚焦于在保留核心语义的前提下压缩 KV 缓存。部分方法通过仅保留影响最大的 Tokens 来降低内存占用。</p>
<p>这类方法证明，通过筛选、检索增强或压缩重编码，隐式记忆可被转换为更高效的记忆表征，使大语言模型无需依赖原始缓存复用，就能扩展可用上下文长度并提升推理性能。</p>
<p>**其主要优势在于能生成更紧凑、信息密度更高的记忆表征：既降低了存储成本，又支持在长上下文场景下高效检索；通过重塑隐式状态，模型可获取经过提炼的语义信号，这类信号往往比原始激活值更具实用价值。**然而，转换过程存在信息丢失风险，且与直接复用的 KV 缓存相比，压缩后的状态更难解释与验证。此外，剪枝、聚合或重编码所需的额外计算，也会增加系统复杂度。</p>
<h3 id="2-4-适配性"><a href="#2-4-适配性" class="headerlink" title="2.4 适配性"></a>2.4 适配性</h3><p>智能体系统中记忆类型的选择，反映了设计者对智能体在特定任务中行为表现的预期。设计者的目标不只是让智能体记住特定信息，更是通过记忆类型的选择，<strong>隐性地定义信息对智能体行为的塑造方式</strong>。</p>
<table>
<thead>
<tr>
<th>记忆形式</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>词元级记忆</td>
<td>符号化<br />可寻址<br />高透明性<br />显式推理<br />可控性<br />可追溯性</td>
<td>聊天机器人与多轮对话系统<br />需要稳定记忆的长周期或终身智能体<br />用户专属个性化档案<br />推荐系统<br />企业或组织知识库<br />法律、合规等需要可验证溯源性的高风险领域</td>
</tr>
<tr>
<td>参数化记忆</td>
<td>隐性化<br />抽象化<br />可泛化<br />概念理解与广泛模式归纳的任务</td>
<td>角色扮演或人设一致性行为<br />数学推理<br />代码编写<br />博弈及结构化问题求解<br />人类对齐与规范性行为先验<br />风格化、专业化或领域专家级响应</td>
</tr>
<tr>
<td>隐式记忆</td>
<td>隐私保护特性<br />性能与可扩展性，而非可解释性<br />高知识密度与高压缩比<br />适合资源受限或高度动态的环境。</td>
<td>多模态或全集成智能体架构<br />端侧或边缘部署及云服务环境<br />加密或隐私敏感型应用领域</td>
</tr>
</tbody></table>
<h2 id="三、记忆的功能：智能体为何需要记忆？"><a href="#三、记忆的功能：智能体为何需要记忆？" class="headerlink" title="三、记忆的功能：智能体为何需要记忆？"></a>三、记忆的功能：智能体为何需要记忆？</h2><blockquote>
<p>智能体记忆并非单一的组件，而是由<strong>一系列独立的功能模块</strong>构成的集合；在支撑智能体实现长期、智能的行为表现上，每个模块都承担着独一无二的使命。</p>
</blockquote>
<p>将大型语言模型从<strong>通用型无状态文本处理器</strong>，转变为<strong>自主化、目标导向的智能体</strong>，这绝非简单的渐进式升级，而是一次根本性的范式变革。这一变革凸显出<strong>无状态性</strong>的关键局限。从定义上而言，智能体必须具备长期存续、持续适应环境以及连贯交互的能力。要实现这些能力，仅依靠大上下文窗口远远不够，其核心支撑是<strong>记忆能力</strong>。</p>
<p>核心是三大记忆功能系统，这三大记忆系统并非孤立存在，而是构成了一套<strong>动态互联的架构</strong>，并以此定义了智能体的<strong>认知闭环</strong>。</p>
<table>
<thead>
<tr>
<th>记忆系统</th>
<th>核心问题</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>事实记忆</strong></td>
<td><strong>智能体知道什么？</strong></td>
<td>智能体的陈述性知识库<br />其建立目的是通过调取显性事实、用户偏好与环境状态，保障智能体交互的一致性、连贯性与适应性。</td>
</tr>
<tr>
<td><strong>经验记忆</strong></td>
<td><strong>智能体如何实现自我提升？</strong></td>
<td>智能体的过程性与策略性知识体系<br />其形成机制是从过往任务轨迹、失败教训与成功经验中提炼规律，以此支撑智能体的持续学习与自我进化。</td>
</tr>
<tr>
<td><strong>工作记忆</strong></td>
<td><strong>智能体当前正在处理什么信息？</strong></td>
<td>智能体在单任务或单会话流程中，用于动态管理当前上下文的、容量受限的临时工作区。</td>
</tr>
</tbody></table>
<p>该循环起始于<strong>编码阶段</strong>：智能体将交互产生的结果（例如新获取的事实、或某一计划的失败结论），通过总结、反思或抽象的方式，整合固化为长时记忆。</p>
<p>随后，<strong>处理阶段</strong>在工作记忆中进行 —— 工作记忆在此承担着支撑即时推理的<strong>动态工作区</strong>角色。为了保障这一推理过程的顺利开展，系统会启动<strong>检索机制</strong>，从事实记忆与经验记忆的持久化存储库中调取相关的上下文信息与技能知识，并将其注入工作记忆。</p>
<p>这套<strong>编码 - 处理 - 检索</strong> (Encoding-Processing-Retrieval) 的流程构成了智能体的核心架构模式，使其能够同时实现<strong>从过往经验中学习</strong>与<strong>基于当下场景进行推理</strong>两大关键能力。</p>
<h3 id="3-1-事实记忆：持久的认知基础与清晰的外部事实"><a href="#3-1-事实记忆：持久的认知基础与清晰的外部事实" class="headerlink" title="3.1 事实记忆：持久的认知基础与清晰的外部事实"></a>3.1 事实记忆：持久的认知基础与清晰的外部事实</h3><blockquote>
<p><strong>事实记忆</strong>是指智能体存储和检索与过往事件、用户专属信息及外部环境状态相关的<strong>显性陈述性事实</strong>的能力。这类信息涵盖的内容十分广泛，包括对话历史、用户偏好以及外部世界的相关属性。事实记忆能够让智能体在解读当前输入时，充分利用历史信息，因此它是智能体实现<strong>上下文感知、个性化响应</strong>以及<strong>复杂任务规划</strong>的基石。</p>
</blockquote>
<p>在神经科学中，陈述性记忆指的是可被主体有意识调取的长时记忆存储系统，该系统通常被拆解为两大核心组成部分进行分析，即<strong>情景记忆</strong>与<strong>语义记忆</strong>。</p>
<ul>
<li>情景记忆存储的是与特定时空背景相关的个体亲历事件，记录着某一事件的 “内容、地点与时间”。它的核心特征是能够让主体在脑海中 “重现” 过往的事件。</li>
<li>语义记忆则用于存储通用事实知识、概念以及词汇含义，这类信息的留存<strong>不依赖于其被获取时的具体场景</strong>。</li>
</ul>
<p>在人类大脑中，情景记忆与语义记忆依托同一个陈述性记忆系统发挥作用，但二者代表着两种不同层次的抽象表征。</p>
<p>在智能体系统中，这种源于生物学的分类方式并未被设定为僵化的二元对立结构，而是被转化为一套<strong>连续性的处理流程</strong>。系统通常会先将具体的交互历史（如对话轮次、用户行为、环境状态等）记录为情景轨迹。在后续的处理阶段，系统会依次执行<strong>信息总结</strong>、<strong>反思提炼</strong>、<strong>实体抽取</strong>以及<strong>事实归纳</strong>等操作。经过上述处理得到的抽象化信息，会被存储在向量数据库、键值存储系统或知识图谱等结构中，同时由专门的流程负责执行<strong>去重</strong>与<strong>一致性校验</strong>。通过这一系列流程，原始的事件数据流会逐步转化为可复用的<strong>语义事实库</strong>。</p>
<p>从功能层面来看，这套架构能够确保智能体在交互过程中具备三项核心属性：<strong>一致性、连贯性与适应性</strong>。</p>
<ul>
<li><strong>一致性</strong>：指智能体的行为表现与自我呈现能够长期保持稳定。通过对用户专属事实与自身承诺维持稳定的内部存储状态，智能体可以避免出现立场矛盾或随意变更态度的情况。</li>
<li><strong>连贯性</strong>：体现为智能体具备稳健的上下文感知能力。它能够调取并整合相关的交互历史，参考用户过往的输入内容，维持话题的连续性，从而确保输出的响应能够构成逻辑连贯的对话，而非孤立的语句。</li>
<li><strong>适应性</strong>：指智能体能够基于存储的用户画像与历史反馈，实现行为的个性化调整。因此，智能体的响应风格与决策逻辑会逐步贴合用户的具体需求与特征。</li>
</ul>
<p><strong>事实记忆的两大类型</strong></p>
<table>
<thead>
<tr>
<th>事实记忆类型</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>用户事实记忆</td>
<td>指支撑人机交互一致性的相关事实，包括用户身份信息、稳定偏好、任务约束条件以及历史承诺等内容。</td>
</tr>
<tr>
<td>环境事实记忆</td>
<td>指支撑智能体与外部世界保持一致性的相关事实，例如文档状态、资源可用性以及其他智能体的能力范围等。</td>
</tr>
</tbody></table>
<h4 id="3-1-1-用户事实记忆：持久的认知基础"><a href="#3-1-1-用户事实记忆：持久的认知基础" class="headerlink" title="3.1.1 用户事实记忆：持久的认知基础"></a>3.1.1 用户事实记忆：持久的认知基础</h4><blockquote>
<p>用户事实记忆用于跨会话、跨任务存储与特定用户相关的可验证事实，包括用户身份信息、偏好、行为习惯、历史承诺以及关键事件等内容。其核心功能是规避无状态交互模式下的典型失效问题，例如指代偏差、重复询问以及响应矛盾等，进而减少对长周期任务目标的干扰。</p>
</blockquote>
<p>在工程实践中，构建用户事实记忆通常包含筛选与压缩、结构化组织、检索与复用、一致性管控四大环节，目标是在访问成本可控的前提下，维持长期对话与行为的连贯性。</p>
<p><strong>对话连贯性</strong>：对话连贯性要求智能体在较长周期内，持续保留对话上下文、用户专属事实以及稳定的人设特征。这能确保后续对话回合能够呼应前期用户披露的信息与情感倾向，避免陷入重复澄清或回答自相矛盾的困境。为实现这一目标，主流系统采用启发式筛选与语义抽象两种互补策略来构建用户事实记忆。</p>
<p><strong>目标一致性</strong>：目标一致性要求智能体长期维护并优化显性的任务表征。这能确保智能体提出的澄清问题、发起的信息请求以及执行的行动，始终与核心任务目标严格对齐，最大限度减少意图偏移。</p>
<p>通过融合基于检索的排序策略与生成式抽象技术，用户事实记忆模块将系统能力从简单的相似度匹配，升级为对显性任务目标与约束条件的主动维护。这一技术架构带来双重优势：一方面，通过长期行为连贯性为用户营造熟悉感与信任感；另一方面，通过提升任务成功率、减少冗余操作、降低错误修复成本，有效提高系统的运行效率。</p>
<p>综合来看，上述机制能够将短暂易逝的交互轨迹，转化为智能体持久的认知基础。</p>
<h4 id="3-1-2-环境事实记忆：清晰的外部事实"><a href="#3-1-2-环境事实记忆：清晰的外部事实" class="headerlink" title="3.1.2 环境事实记忆：清晰的外部事实"></a>3.1.2 环境事实记忆：清晰的外部事实</h4><blockquote>
<p>环境事实记忆针对用户以外的外部实体与状态，涵盖长文档、代码库、工具以及交互轨迹等内容。该记忆模式可解决事实召回不完整、来源不可验证的问题，减少多智能体协作过程中的矛盾与冗余，同时提升智能体在异构环境中执行长周期任务的稳定性。其核心目标是构建一个可更新、可检索、可管控的外部事实层，为跨会话、跨阶段的任务执行提供稳定参考。</p>
</blockquote>
<p>具体而言，现有技术方案可从两个互补维度进行分类：知识持久化与多智能体共享访问。</p>
<p><strong>知识持久化</strong>是指对通用知识与领域专属知识进行持久化表征，支撑长文档分析、事实问答、多跳推理以及代码与数据资源的可靠检索等任务。在知识组织层面，现有研究的核心方向是对外部数据进行结构化处理，以增强推理能力。</p>
<p><strong>共享访问</strong>旨在为多智能体协作构建可视化、可管理的公共事实基础，实现目标对齐、中间成果传递与冗余工作消减。该机制确保单个智能体能够直接受益于群体知识，从而减少矛盾结论的产生，提升系统整体效率。</p>
<p>环境事实记忆构建了一个可持续更新、可审计、可复用的外部事实层。在知识维度，它通过结构化组织与长时记忆模块，提升了事实召回的完整性、可解释性与可编辑性；在协作维度，它借助共享与管控机制，维持了跨智能体、跨阶段的一致性，从而使系统能够在长周期、多主体、多源信息的复杂条件下，实现稳健的决策与执行。</p>
<h3 id="3-2-经验记忆：抽象与习得"><a href="#3-2-经验记忆：抽象与习得" class="headerlink" title="3.2 经验记忆：抽象与习得"></a>3.2 经验记忆：抽象与习得</h3><blockquote>
<p>经验记忆是智能体将<strong>历史任务轨迹、提炼的策略以及交互结果</strong>编码为持久化、可检索表征的机制。不同于负责管理临时上下文的工作记忆，经验记忆聚焦于<strong>跨不同任务场景的长期知识积累与迁移</strong>。</p>
</blockquote>
<p>这一范式在理论层面以认知科学为基础，与人类的<strong>非陈述性记忆</strong>（尤其是程序性记忆与习惯养成系统）具有相似性。在生物系统中，内隐式技能的习得依赖分布式神经回路的作用。与之不同的是，智能体的经验记忆通常采用<strong>显式数据结构</strong>（如向量数据库或符号化日志）来实现。这种技术实现上的差异，赋予了智能体一项生物系统不具备的独特能力：<strong>对自身程序性知识进行内省、编辑与推理的能力</strong>。</p>
<p>至关重要的是，在这个以经验为核心的时代，经验记忆是智能体实现<strong>持续学习与自我进化的基石</strong>。通过维护一个结构化的经验存储库，智能体得以通过<strong>非参数化的方式</strong>完成自适应调整，规避了频繁进行参数更新所产生的高昂成本。该机制通过将交互反馈转化为可复用知识，有效形成了<strong>学习闭环</strong>。</p>
<p>借助这一过程，智能体能够修正过往错误、提炼可泛化的启发式策略，并固化常规行为模式。因此，这种自适应调整可减少冗余计算，实现决策能力的持续优化。</p>
<p><strong>经验记忆的三大类型</strong></p>
<table>
<thead>
<tr>
<th>记忆类型</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>案例记忆</td>
<td>存储经过最低限度处理的历史任务场景记录，优先保证信息的高保真度，以支持直接的场景复现与模仿学习。这类记忆保留了 “场景 - 结果” 的原始对应关系，可作为一个<strong>具象化、可验证的证据库</strong>，充当基于证据驱动学习的上下文范例。</td>
</tr>
<tr>
<td>策略记忆</td>
<td>从过往任务轨迹中提炼具备迁移性的推理模式、工作流程与高阶洞见，用以指导不同场景下的任务规划。它扮演着<strong>认知脚手架</strong>的角色，将决策逻辑与具体场景解耦，从而提升跨任务泛化能力，并压缩复杂推理的搜索空间。</td>
</tr>
<tr>
<td>技能记忆</td>
<td>封装可直接执行的过程性能力，覆盖范围从原子化代码片段到标准化 API 协议不等，能够将抽象策略转化为可验证的具体行动。这类记忆是智能体的<strong>主动执行基底</strong>，可支撑智能体能力的模块化拓展，以及对工具使用类环境的高效处理。</td>
</tr>
</tbody></table>
<h4 id="3-2-1-案例记忆：高级推理的基础模板"><a href="#3-2-1-案例记忆：高级推理的基础模板" class="headerlink" title="3.2.1 案例记忆：高级推理的基础模板"></a>3.2.1 案例记忆：高级推理的基础模板</h4><blockquote>
<p>案例型记忆存储经过最低限度处理的历史事件记录，优先保证信息的高保真度，确保相关任务场景可被复现，或作为上下文范例加以复用。与策略记忆、技能记忆不同，案例记忆不进行深度抽象，从而完整保留了场景与解决方案之间的原始对应关系。</p>
</blockquote>
<p><strong>任务轨迹类</strong>记忆保存交互序列，支持场景复现与基于证据的学习。<strong>解决方案类</strong>记忆将记忆模块作为已验证解决方案的存储库。</p>
<p>案例型记忆具备高信息保真度，可为模仿学习提供可验证的证据支撑。但另一方面，由于这类记忆依赖原始数据存储，也面临着检索效率低与上下文窗口占用率高的挑战。与可执行的技能、抽象的策略不同，案例本身不包含编排逻辑或功能接口，而是作为支撑高层级推理的事实基底发挥作用。</p>
<h4 id="3-2-2-策略记忆：具备泛化能力的认知手脚架"><a href="#3-2-2-策略记忆：具备泛化能力的认知手脚架" class="headerlink" title="3.2.2 策略记忆：具备泛化能力的认知手脚架"></a>3.2.2 策略记忆：具备泛化能力的认知手脚架</h4><blockquote>
<p>不同于记录 “发生了什么” 的案例库，策略型记忆提炼的是 “如何行动” 的可迁移知识，涵盖可复用的推理模式、任务分解方法、经验洞见、抽象结论以及跨场景工作流程。它将经验升华为可编辑、可审计且可组合的高阶知识，从而减少对冗长轨迹复现的依赖，提升跨任务泛化能力与执行效率。</p>
</blockquote>
<p>根据所存储知识的粒度与结构复杂度，策略记忆划分为三种类型：原子化洞见、序列化工作流与框架化模式。</p>
<ul>
<li>**原子化洞见：**这类方法的核心是从历史任务轨迹中提炼出离散的知识单元，例如细粒度决策规则与反思性启发策略。</li>
<li>**序列化工作流：**与原子化、静态的洞见不同，工作流将策略封装为结构化的动作序列：这类可执行的例行流程是从历史轨迹中抽象而来，用于在推理阶段指导多步骤任务的执行。</li>
<li>**框架化模式：**在更高的抽象层级上，推理模式是一种认知模板，它封装了问题求解的核心结构；智能体通过实例化这些具备泛化能力的框架，能够处理复杂的推理任务。这些技术进展标志着一种范式转变：从描述性规则转向可移植的推理结构。</li>
</ul>
<p>**涵盖洞见、工作流与模式的策略记忆，是支撑生成式推理的高层级脚手架。**与依赖检索具体原始轨迹（这类轨迹往往存在噪声且依赖特定上下文）的案例记忆不同，策略记忆提炼出具备泛化能力的框架，能够有效压缩推理的搜索空间，提升智能体在未见过的任务上的稳健性。但需要明确的是，这些策略仅作为结构性指导，而非可直接执行的动作：它们负责引导规划过程，却无法直接与环境交互。</p>
<p>这一局限性催生了下一节将要讨论的技能型记忆，即存储可调用能力与工具的记忆类型。最终，稳健的智能体通常会将这两类记忆协同使用：策略提供抽象的规划逻辑，而技能负责落地执行。</p>
<h4 id="3-2-3-技能记忆：认知进化的核心动力"><a href="#3-2-3-技能记忆：认知进化的核心动力" class="headerlink" title="3.2.3 技能记忆：认知进化的核心动力"></a>3.2.3 技能记忆：认知进化的核心动力</h4><blockquote>
<p>技能型记忆承载智能体的过程性执行能力，并将抽象策略转化为可验证的具体行动。它对智能体 “能做什么” 进行编码，与记录智能体 “知道什么” 的陈述性知识形成互补，同时通过提供可调用、可测试且可组合的执行单元，成为支撑 “感知-推理-行动” 闭环的核心锚点。</p>
</blockquote>
<p><strong>语言模型能够习得工具调用的时机与方法，且其性能可随工具库规模的扩大而稳定提升，这使得技能记忆成为现代智能体的执行基底。</strong></p>
<p>技能记忆的覆盖范围形成一个连续谱系：一端是智能体内部的细粒度代码，另一端是外部标准化接口。其界定标准清晰统一：技能必须可被智能体主动调用，技能执行的结果必须可验证以支撑持续学习，且技能必须能与其他技能组合，形成更复杂的执行流程。</p>
<ul>
<li>**代码片段：**可执行代码以可复用片段的形式存储，是智能体将经验快速转化为能力的直接途径。在开放式任务中，智能体可将成功的子任务轨迹提炼为可解释程序，并在不同环境中复用。</li>
<li>**函数与脚本：**将复杂行为抽象为模块化函数或脚本，可显著提升技能的复用性与泛化能力。近期研究进展使智能体能够自主创建面向特定问题的专用工具，并能在移动图形用户界面、网页导航、软件工程等多元领域中，通过示范学习与环境反馈优化工具调用能力。此外，过程性记忆的新兴机制可支持智能体将执行轨迹提炼为可检索脚本，助力其高效泛化至全新任务场景。</li>
<li>**应用程序编程接口（API）：**封装技能的通用交互界面。早期研究的核心是微调模型以实现工具的正确调用，但随着 API 库规模呈指数级增长，当前的核心瓶颈已转向检索环节。传统的信息检索方法往往难以捕捉工具的功能语义。为此，近期研究开始采用基于学习的检索与重排序策略，该策略会综合考量工具文档质量、工具间层级关系以及协同使用模式，从而打通用户意图与可执行函数之间的衔接链路。</li>
<li>**模型上下文协议（MCP）：**为解决基于 API 的生态系统中存在的协议碎片化问题，模型上下文协议提出了一套开放式标准，统一了智能体发现、使用工具与数据的方式，其中包括按需加载工具、降低上下文开销的代码执行模式。</li>
</ul>
<p>**综上，技能型记忆是智能体的主动执行基底，其形态已从静态代码片段、模块化脚本，逐步演进至标准化 API 与可学习架构。**它通过将案例型记忆与策略型记忆中的经验洞见转化为可验证的执行流程，搭建起抽象规划与环境交互之间的桥梁。随着工具创建、检索与互操作机制（如模型上下文协议）的日趋成熟，技能型记忆已超越单纯的存储功能，构建起 “能力合成-优化迭代-落地执行” 的持续闭环，成为驱动智能体实现开放式进化的核心动力。</p>
<h4 id="3-2-4-混合记忆：全面的认知架构"><a href="#3-2-4-混合记忆：全面的认知架构" class="headerlink" title="3.2.4 混合记忆：全面的认知架构"></a>3.2.4 混合记忆：全面的认知架构</h4><blockquote>
<p>先进的智能体架构正越来越多地采用<strong>混合式设计</strong>，整合多种经验记忆形式，以此平衡<strong>具象化证据</strong>与<strong>可泛化逻辑</strong>的关系。这类系统通过维护一套覆盖原始任务场景、提炼规则与可执行技能的知识谱系，能够动态选择最适配的记忆形式，既保证检索精度，又实现跨场景的广泛泛化。</p>
</blockquote>
<p>该领域的一个重要研究方向是<strong>结合案例记忆与策略记忆</strong>，实现二者的互补推理。此外，近期的技术框架还致力于<strong>统一记忆的全生命周期管理</strong>，例如构建全面的认知架构。</p>
<h3 id="3-3-工作记忆：主动压缩信息，锚定未来行动"><a href="#3-3-工作记忆：主动压缩信息，锚定未来行动" class="headerlink" title="3.3 工作记忆：主动压缩信息，锚定未来行动"></a>3.3 工作记忆：主动压缩信息，锚定未来行动</h3><p>在认知科学领域，工作记忆被定义为一种容量有限、可动态调控的机制，它通过实时筛选、维持并转化与任务相关的信息，为更高级别的认知活动提供支撑。它的作用绝非单纯的临时存储，更意味着在资源受限条件下对信息的主动管控。</p>
<blockquote>
<p>工作记忆可被定义为：在单一任务场景内，对上下文进行主动管理与加工的一系列机制的集合。其核心目标是将上下文窗口从被动缓存区，转变为可调控、可更新、抗干扰的工作空间。这一转变能够带来立竿见影的效益：在固定注意力资源预算下提升任务相关信息的密度，抑制冗余与噪声数据的干扰，并支持对表征内容进行重写或压缩，从而维持连贯的思维链。</p>
</blockquote>
<p>标准的上下文窗口主要扮演着被动只读缓存区的角色。尽管模型在推理过程中能够调用上下文窗口内的内容，但它缺乏可动态筛选、维持或转化当前工作空间的显式机制。最新的行为学研究证据表明，现有模型尚未展现出类人水平的工作记忆特性，这也凸显出为模型设计显式可操作的工作记忆机制的必要性。</p>
<p><strong>工作记忆的两种类型</strong></p>
<table>
<thead>
<tr>
<th>记忆类型</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>单轮次工作记忆</td>
<td>聚焦于输入信息的浓缩与抽象。在这类应用场景中，系统需要在单次前向传播过程内，处理海量即时输入数据，例如长文档或高维多模态数据流。其核心目标是动态筛选并重构证据信息，构建一个容量受限的计算工作区，从而最大化每个符号（token）的有效信息负载量。</td>
</tr>
<tr>
<td>多轮次工作记忆</td>
<td>致力于时序状态的维持。在多轮次交互场景下，核心挑战在于避免历史信息的持续累积对注意力机制造成过载。这就需要通过 “读取 — 执行 — 更新” 的持续循环，维持任务状态、目标与约束条件，确保跨轮次的中间成果能够被有效整合与凝练。</td>
</tr>
</tbody></table>
<p><strong>面向大语言模型的工作记忆，标志着一种朝向任务场景内主动上下文管理的范式转变。通过契合 “主动加工信息” 这一认知科学核心要求，它能够有效抑制信息干扰，并为长上下文推理面临的工程约束难题，提供切实可行的解决方案。</strong></p>
<h4 id="3-3-1-单轮次工作记忆：主动压缩信息"><a href="#3-3-1-单轮次工作记忆：主动压缩信息" class="headerlink" title="3.3.1 单轮次工作记忆：主动压缩信息"></a>3.3.1 单轮次工作记忆：主动压缩信息</h4><blockquote>
<p>单轮次工作记忆旨在解决单次前向传播过程中处理海量即时输入数据的难题，这些输入包括长文档与高维多模态数据流。这类记忆的目标并非被动读取全部上下文信息，而是主动构建一个可写入的工作区。具体操作是在固定的注意力与内存资源预算下，对原始信息进行筛选与转换，以此提升信息密度与可操作性。</p>
</blockquote>
<p>这类机制可划分为两类：一类是输入压缩，用于减少物理符号（token）数量；另一类是观测抽象，用于将数据转化为结构化的语义表征。</p>
<ul>
<li><strong>输入压缩技术的核心是 “精简数据规模”</strong>，目的是对上下文进行预处理，在保留关键信息的前提下最大限度减少符号用量（蒋等人，2023）。这类方法主要分为三种范式：硬压缩、软压缩与混合压缩。<ul>
<li>硬压缩基于重要性指标对符号进行离散化筛选。尽管硬压缩效率较高，但这种离散筛选的方式，存在破坏文本句法或语义关联的风险。</li>
<li>软压缩将长度不固定的上下文编码为高密度的潜在向量（即记忆槽）。这种方式能实现较高的压缩比，但需要额外的训练过程，且可能会丢失细粒度的信息细节。</li>
<li>混合压缩方法试图调和上述两种方法的利弊，将全局语义适配器（软压缩）与符号级保留概率（硬压缩）相结合。</li>
</ul>
</li>
<li>**观测抽象的目标则是 “将原始观测数据转化为便于推理的结构化格式”。**该机制能够将动态变化的高维观测空间，映射为固定尺寸的记忆状态，避免智能体被海量原始数据淹没。</li>
</ul>
<p>单轮次工作记忆充当着<strong>主动压缩层</strong>的角色，其作用是最大化上下文窗口对即时推理的效用。通过采用输入压缩与观测抽象两类机制，单轮次工作记忆能够有效提升运算工作区的信息密度，确保在容量受限的前提下保留关键证据。但需要注意的是，这类优化严格限定在<strong>单轮交互内部</strong>；它解决的是静态输入的广度与复杂度问题，而非动态交互的时序连续性问题。</p>
<h4 id="3-3-2-多轮次工作记忆：锚定未来行动"><a href="#3-3-2-多轮次工作记忆：锚定未来行动" class="headerlink" title="3.3.2 多轮次工作记忆：锚定未来行动"></a>3.3.2 多轮次工作记忆：锚定未来行动</h4><blockquote>
<p>多轮次工作记忆所应对的问题域，与单轮次场景存在本质区别。在长周期交互任务中，核心瓶颈已从瞬时上下文容量转变为任务状态与历史关联性的持续维护。即便扩展了上下文窗口，历史信息的不断累积仍会不可避免地耗尽注意力资源、增加推理延迟，并引发目标偏移。为缓解这一问题，多轮次场景下的工作记忆承担起外置式状态载体的角色，构建起 “读取-评估-写入” 的持续循环机制。其核心目标是在有限的资源预算内，确保关键状态信息可被高效调取且保持一致性。</p>
</blockquote>
<p>依据状态管理策略，将这类机制划分为三类：状态整合、层级折叠与认知规划。</p>
<ul>
<li>**状态整合：**在连续的交互数据流中，状态整合通过动态更新，将持续增长的交互轨迹映射至固定尺寸的状态空间。</li>
<li>**层级折叠：**针对复杂的长周期任务，单纯的线性摘要已无法满足状态维护的需求。层级折叠策略基于子任务目标对交互轨迹进行分解，仅在子任务执行期间保留细粒度的交互轨迹；当子任务完成后，便将对应的子轨迹提炼为简洁的摘要信息。这种 “先分解、后整合” 的策略，使工作记忆能够实现动态的扩容与收缩。通过用稳定的高层级抽象信息替代已完成的子轨迹，这类方法既能保留关键上下文，又能维持较小的活跃窗口尺寸。</li>
<li>**认知规划：**在最高的抽象层级，工作记忆负责创建并维护外置式的规划方案或世界模型。此时，记忆状态的作用不再局限于总结过往，更成为指导未来行动的前瞻性结构。在具身智能与自主智能体场景中，研究人员将语言模型视为高层级规划器，使规划方案成为工作记忆的核心。通过将规划方案与结构化环境表征作为工作记忆的可读写核心，智能体不仅能维持目标一致性，还能在感知出现偏差时稳健地调整策略。</li>
</ul>
<p>**多轮次工作记忆的核心在于构建可操作的状态载体，而非简单保留原始历史信息。它整合了三类关键机制：状态整合用于压缩连续数据流，层级折叠用于结构化组织子轨迹，认知规划用于锚定未来行动。**这些机制有效实现了推理性能与交互长度的解耦，使智能体能够在严格的计算与内存约束下，于无限长的交互周期中维持时序连贯性与目标对齐性。</p>
<h2 id="四、记忆的动态：记忆是如何运行与演进？"><a href="#四、记忆的动态：记忆是如何运行与演进？" class="headerlink" title="四、记忆的动态：记忆是如何运行与演进？"></a>四、记忆的动态：记忆是如何运行与演进？</h2><p>记忆的形式与功能勾勒出智能体记忆的<strong>相对静态的概念框架</strong>。然而，这种静态视角忽略了智能体记忆的本质特征：<strong>内在动态性</strong>。</p>
<p>与静态编码在模型参数或固定数据库中的知识不同，智能体记忆系统能够动态构建并更新自身的记忆库，还能根据不同的查询需求执行定制化的检索操作。这种自适应能力，是智能体实现自我进化与终身学习的关键所在。</p>
<blockquote>
<p>智能体记忆系统能够基于推理轨迹与环境反馈，自主提炼出经过精简且具备泛化能力的知识。通过将这些新提炼的知识与已有记忆库进行动态融合和更新，该系统既能持续适应不断变化的外部环境，又能有效缓解认知层面的冲突矛盾。基于已构建的记忆库，系统可在精准的时机从指定的记忆模块中执行定向检索，从而切实提升推理效能。</p>
</blockquote>
<p>动态记忆生命周期，清晰揭示了记忆形成、记忆演进与记忆检索这三个环节如何相互作用，共同支撑智能体的自适应与自我进化行为。</p>
<p><strong>记忆系统的三大基础过程</strong></p>
<table>
<thead>
<tr>
<th>记忆过程</th>
<th>核心</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>记忆形成</strong></td>
<td><strong>如何提取记忆？</strong></td>
<td>该过程聚焦于将原始经验转化为高信息密度的知识。<br />记忆系统并非被动记录所有交互历史，而是会选择性地甄别具备长期实用价值的信息，例如成功的推理模式或环境约束条件。</td>
</tr>
<tr>
<td><strong>记忆演进</strong></td>
<td><strong>如何优化记忆？</strong></td>
<td>该过程体现了记忆系统的动态演化特性。<br />它的核心是将新形成的记忆与已有记忆库进行整合。通过相关记忆条目合并、冲突消解、自适应剪枝等机制，系统能够确保在不断变化的环境中，自身记忆始终具备可泛化性、连贯性与高效性。</td>
</tr>
<tr>
<td><strong>记忆检索</strong></td>
<td><strong>如何利用记忆？</strong></td>
<td>该过程决定了记忆检索的质量。<br />系统会基于当前上下文，构建一个任务感知型查询语句，并采用精心设计的检索策略调取对应的记忆库。由此检索出的记忆，在语义层面与当前任务相关，同时在功能层面对推理过程具有关键作用。</td>
</tr>
</tbody></table>
<p>这三个过程并非相互独立，而是构成了一个<strong>相互关联的循环体系</strong>，驱动着记忆系统的动态演进与运行。</p>
<blockquote>
<p>在<strong>记忆形成阶段</strong>提取的记忆，会在<strong>记忆演进阶段</strong>与已有记忆库进行整合与更新。借助前两个阶段所构建的记忆库，<strong>记忆检索阶段</strong>得以实现定向调取，进而优化推理过程。反过来，推理结果与环境反馈又会回流至记忆形成阶段，用于提炼新的经验洞见；同时也会作用于记忆演进阶段，助力记忆库的优化迭代。</p>
</blockquote>
<p>综合来看，这些环节共同推动着大语言模型，从<strong>静态的条件生成器</strong>，转变为能够从动态变化的环境中持续学习并做出响应的<strong>动态系统</strong>。</p>
<h3 id="4-1-记忆的形成：从信息的简单压缩，到经验的长期拥有"><a href="#4-1-记忆的形成：从信息的简单压缩，到经验的长期拥有" class="headerlink" title="4.1 记忆的形成：从信息的简单压缩，到经验的长期拥有"></a>4.1 记忆的形成：从信息的简单压缩，到经验的长期拥有</h3><blockquote>
<p><strong>记忆形成</strong>定义为将原始上下文（如对话或图像）编码为紧凑知识的过程。</p>
<p>记忆形成的必要性源于处理冗长、含噪且高度冗余的原始上下文时存在的规模限制。全上下文提示往往会产生计算开销大、内存占用过高的问题，并且在分布外的输入长度下推理性能会下降。</p>
</blockquote>
<p>基于信息压缩的粒度与编码逻辑，我们将记忆形成过程划分为<strong>五种不同类型</strong>。</p>
<p><strong>记忆形成的五大类别</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>语义摘要</strong><br />Semantic Summarization</td>
<td>将冗长的原始数据转化为紧凑摘要，在过滤冗余信息的同时保留全局性的高层语义信息，从而降低上下文开销。</td>
</tr>
<tr>
<td><strong>知识蒸馏</strong><br />Knowledge Distillation</td>
<td>提取特定的认知资源，涵盖从事实细节到经验规划策略的各类内容。</td>
</tr>
<tr>
<td><strong>结构化构建</strong><br />Structured Construction</td>
<td>将无定形的源数据组织为显式的拓扑表征（如知识图谱或层级树），以此提升记忆的可解释性，并支持多跳推理。</td>
</tr>
<tr>
<td><strong>隐式表征</strong><br />Latent Representation</td>
<td>在连续隐空间内，将原始经验直接编码为机器原生格式（如向量嵌入或键值状态）。</td>
</tr>
<tr>
<td><strong>参数内化</strong><br />Parametric Internalization</td>
<td>通过参数更新，将外部记忆直接整合到模型的权重空间中，从而将可检索信息有效转化为智能体的内在能力与本能。</td>
</tr>
</tbody></table>
<h4 id="4-1-1-语义摘要：全局压缩"><a href="#4-1-1-语义摘要：全局压缩" class="headerlink" title="4.1.1 语义摘要：全局压缩"></a>4.1.1 语义摘要：全局压缩</h4><blockquote>
<p>语义摘要将原始观测数据转化为<strong>紧凑且语义丰富的摘要</strong>。生成的摘要能够捕捉原始数据的全局性、高层级信息，而非具体的事实性或经验性细节。此类摘要的典型示例包括文档的核心主旨、任务的流程脉络以及用户的历史画像。</p>
</blockquote>
<p>通过过滤冗余内容并保留与任务相关的全局语义，语义摘要为后续推理提供了一份<strong>高层级的指导性框架</strong>，同时不会产生过多的上下文开销。实现该压缩效果主要有两种方式：增量式语义摘要与分区式语义摘要。</p>
<p><strong>增量式语义摘要</strong></p>
<ul>
<li><p>该范式采用时序融合机制，持续将新观测到的信息与已有摘要进行融合，生成能够动态演化的全局语义表征。这种逐块处理的范式支持增量学习，规避了全序列处理带来的计算复杂度，并推动全局语义的渐进式收敛。</p>
</li>
<li><p>随着增量式摘要从启发式融合发展到过滤式融合，再到基于学习的优化，模型对摘要生成能力的掌握程度逐渐内化，进而降低了多轮迭代过程中的累积误差。尽管如此，其串行更新的本质仍存在计算瓶颈与潜在的信息遗忘问题，这也推动了分区式语义摘要方法的发展。</p>
</li>
</ul>
<p><strong>分区式语义摘要</strong></p>
<ul>
<li>该范式采用空间分解机制，将信息划分为多个独立的语义分区，并为每个分区分别生成摘要。</li>
<li>与增量式摘要相比，分区式方法效率更高，且能捕捉更细粒度的语义。但对各子数据块的独立处理，可能导致跨分区语义关联的丢失。</li>
</ul>
<p>**语义摘要是一种有损压缩机制，旨在从冗长的交互日志中提炼核心主旨。**与逐字存储不同，它优先保证全局语义的连贯性，而非局部事实的精确性，将线性的数据流转化为紧凑的叙事单元。</p>
<p>**语义摘要的核心优势在于高效性：它大幅缩短上下文长度，非常适用于长期对话场景。**但这种优势也伴随着分辨率损失的代价：具体细节或细微线索可能被平滑掉，使其在对证据准确性要求严苛的任务中应用受限。</p>
<h4 id="4-1-2-知识蒸馏：提炼知识"><a href="#4-1-2-知识蒸馏：提炼知识" class="headerlink" title="4.1.2 知识蒸馏：提炼知识"></a>4.1.2 知识蒸馏：提炼知识</h4><blockquote>
<p>语义摘要从宏观层面捕捉原始数据的全局语义，而知识蒸馏则以更精细的粒度运作，从交互轨迹或文档中提取可复用的知识。</p>
</blockquote>
<p>根据任务的底层功能，知识是指各类事实性记忆与经验性记忆。</p>
<p><strong>提炼事实性记忆</strong></p>
<ul>
<li>**这一过程旨在将原始交互内容与文档转化为关于用户及环境状态的显性陈述性知识。**该过程通过留存可验证的事实而非瞬时上下文，确保智能体维持一致性与适应性。</li>
</ul>
<p><strong>提炼经验性记忆</strong></p>
<ul>
<li>**这一过程专注于从历史轨迹中提取任务执行背后的策略。**该范式从成功的任务推演中提炼规划原则，从失败案例中获取修正信号，进而增强智能体在特定任务上的问题解决能力。通过抽象与泛化，该过程还能支持跨任务的知识迁移。因此，经验泛化使智能体能够持续优化自身能力，逐步向终身学习迈进。相关研究致力于从成功与失败的轨迹中提炼高层级规划策略与关键洞察。</li>
</ul>
<p><strong>基础知识蒸馏方法虽简单却至关重要，它是构建更复杂、结构化记忆形成机制的核心基础组件。</strong></p>
<h4 id="4-1-3-结构构建：捕捉复杂逻辑"><a href="#4-1-3-结构构建：捕捉复杂逻辑" class="headerlink" title="4.1.3 结构构建：捕捉复杂逻辑"></a>4.1.3 结构构建：捕捉复杂逻辑</h4><blockquote>
<p>语义摘要与知识蒸馏能够在不同粒度下高效压缩摘要与知识，但二者往往将记忆视为彼此孤立的单元。相比之下，<strong>结构化构建</strong>可将无定形数据转化为规整的拓扑表征。这一过程并非简单的存储格式转换，而是一种主动的结构化操作，它决定了信息的关联方式与层级划分。</p>
</blockquote>
<p>与非结构化的纯文本摘要不同，结构化提取大幅提升了记忆的可解释性与检索效率。尤为关键的是，这类结构化先验在捕捉多跳推理任务中的复杂逻辑与依赖关系时表现优异，相比传统的检索增强方法具备显著优势。</p>
<p>基于底层结构构建的操作粒度，我们将现有方法划分为两类范式：一类是<strong>实体级构建</strong>，即通过将文本拆解为实体与关系来搭建底层拓扑结构；另一类是<strong>数据块级构建</strong>，即通过组织完整的文本片段或记忆单元来构建结构。</p>
<p><strong>实体级构建</strong></p>
<ul>
<li>该范式的基础结构源于<strong>关系三元组提取</strong>，此过程将原始上下文分解为最细粒度的语义原子：实体与关系。</li>
<li>传统方法将记忆建模为平面知识图谱，而近期的研究进展已朝着构建<strong>层级化记忆</strong>的方向发展，以实现对高层抽象信息的捕捉。</li>
</ul>
<p><strong>数据块级构建</strong></p>
<ul>
<li>该范式将连续文本片段或离散记忆单元视为节点，在保留局部语义完整性的前提下，将其组织为拓扑结构。该领域的技术演进路径可概括为：从对固定语料库的静态平面（二维）提取，发展到对新输入轨迹的动态适配，最终走向层级化（三维）架构。</li>
<li>早期方法专注于将固定文本库组织为静态平面结构。为解决这一问题，<strong>动态平面构建方法</strong>应运而生，可在新轨迹输入时增量式构建记忆结构，不同方法的差异体现在底层构建元素上。</li>
<li>近期的技术突破已突破平面布局的局限，开始构建具备更丰富语义深度的<strong>层级化结构</strong>。</li>
</ul>
<p>**结构化构建的核心优势在于可解释性，以及处理复杂关系查询的能力。**这类方法能够捕捉记忆元素之间复杂的语义关联与层级关系，支持基于多步依赖的推理，还能与符号推理或图谱推理框架实现高效集成。</p>
<p>**但其缺点在于模式刚性：**预定义的结构难以表征语义微妙或模糊的信息，且结构的提取与维护成本通常较高。</p>
<h4 id="4-1-4-隐式表征：机器原生"><a href="#4-1-4-隐式表征：机器原生" class="headerlink" title="4.1.4 隐式表征：机器原生"></a>4.1.4 隐式表征：机器原生</h4><p>前文章节聚焦于如何构建基于词元级记忆；本部分则着重探讨将记忆编码为机器原生的隐式表征。</p>
<blockquote>
<p>隐式表征会将原始经验编码为存在于隐空间内的嵌入向量。与 “先对经验进行摘要、再将摘要嵌入向量” 的语义压缩和结构化提取不同，隐式编码会直接将经验存储于隐空间中，从而减少了摘要生成与文本嵌入过程中的信息损耗。此外，隐式编码更契合机器的认知模式，能够实现跨模态的统一表征，同时保证记忆表征兼具稠密性与语义丰富性。</p>
</blockquote>
<p><strong>文本类隐式表征</strong></p>
<p>键值缓存（KV cache）最初的设计目的是加速推理过程，但在记忆研究的语境下，它也可被视作一种隐式表征形式。键值缓存借助额外的存储空间来保存历史信息，以此避免冗余计算。</p>
<ul>
<li>MEMORYLLM 与 M+ 这两种方法，会将记忆表示为可自主更新的隐式嵌入向量，并在推理阶段将其注入 Transformer 中。</li>
<li>MemGen 还引入了 “记忆触发器” 与 “记忆编织器”：前者负责监控智能体的推理状态，判断何时需要显式调用记忆；后者则利用智能体的当前状态构建隐式标记序列。该序列可作为机器原生记忆，有效增强智能体的推理能力。</li>
</ul>
<p><strong>多模态隐式表征</strong></p>
<ul>
<li>当隐式表征与具身智能（Embodied AI）相结合时，多模态隐式记忆能够融合来自多个传感器的数据。隐式编码在实现跨模态统一、高语义丰富度表征方面的具有独特优势。</li>
</ul>
<p>**隐式表征摒弃了人类可读的格式，直接将经验编码为机器原生的向量或键值缓存。**这种高密度的表征形式，能够保留那些在文本解码过程中可能丢失的丰富语义信号，从而更顺畅地与模型的内部计算流程相融合，同时实现无缝的多模态对齐。但隐式表征也存在不透明性的缺陷：隐式记忆本质上是一个 “黑箱”，人类难以对其存储的知识进行调试、编辑或验证。</p>
<h4 id="4-1-5-参数内化：拥有能力"><a href="#4-1-5-参数内化：拥有能力" class="headerlink" title="4.1.5 参数内化：拥有能力"></a>4.1.5 参数内化：拥有能力</h4><p>随着大语言模型越来越多地集成记忆系统以支持长期适配，一个核心研究问题随之产生：<strong>如何将这些外部记忆整合为参数形式</strong>。</p>
<blockquote>
<p>前文讨论的隐式表征方法是在模型外部对记忆进行参数化处理，而<strong>参数内化</strong>则直接调整模型的内部参数。它借助模型的容量，通过已学习的参数空间对信息进行编码与泛化。这一范式从根本上增强了模型的内在能力，既消除了外部存储与检索的开销，又能无缝支持持续更新。</p>
</blockquote>
<p>正如我们之前所阐述的，并非所有记忆内容都具备相同功能：部分记忆条目提供陈述性知识，另一部分则编码影响智能体推理与行为的过程性策略。基于这种差异，我们可以从更细粒度的视角审视记忆内化，将其划分为<strong>知识内化</strong>与<strong>能力内化</strong>两类。</p>
<p><strong>知识内化</strong></p>
<ul>
<li>**该策略旨在将外部存储的事实性记忆（如概念定义或领域知识）转化至模型的参数空间中。**通过这一过程，模型无需依赖显式检索或外部记忆模块，就能直接调用并利用这些事实信息。</li>
<li>在实际应用中，知识内化通常通过<strong>模型编辑技术</strong>实现。</li>
<li>随着低秩适配（LoRA）等参数高效范式的兴起，知识内化无需直接修改模型参数，而是通过轻量化适配器即可完成。尽管取得了上述进展，这些方法仍可能产生<strong>脱靶效应</strong>，且在持续学习场景下容易出现灾难性遗忘问题。</li>
</ul>
<p><strong>能力内化</strong></p>
<ul>
<li>该策略致力于将经验性知识（如过程性专业技能或策略性启发方法）嵌入模型的参数空间。从广义上讲，这一范式属于记忆形成操作的范畴，其核心是从事实性知识的获取转向<strong>经验性能力的内化</strong>。具体而言，这些能力包括特定领域的解决方案框架、策略规划能力，以及智能体技能的高效部署能力等。</li>
<li>在技术实现层面，能力内化通过学习推理轨迹来达成，具体可采用监督微调，或是基于偏好引导的优化方法，例如直接偏好优化（DPO）与广义近端策略优化（GRPO）。</li>
</ul>
<p>作为融合外部检索增强生成（RAG）与参数化训练的一次尝试，**记忆解码器（Memory Decoder）**是一种即插即用的方法：它与外部检索增强生成一样不修改基础模型，同时又通过消除外部检索开销，实现了参数内化级别的推理速度。这类即插即用的参数化记忆技术，未来可能拥有广阔的应用前景。</p>
<blockquote>
<p>参数内化是记忆整合的终极形式，它通过梯度下降将外部知识融合至模型权重中。这一过程实现了范式的转变 —— 从<strong>信息检索</strong>转向<strong>能力拥有</strong>，类似于生物学中的长时程增强效应。当知识被有效内化为模型的本能后，其调用延迟降为零，模型无需查询外部记忆即可快速响应。</p>
</blockquote>
<p>然而，该方法也面临诸多挑战，包括灾难性遗忘与高昂的更新成本。与外部记忆不同，参数内化的内容难以在不产生意外副作用的前提下进行精准修改或删除，这在一定程度上限制了模型的灵活性与适应性。</p>
<h3 id="4-2-记忆的演化：一致且变化的认知与对人类的模拟"><a href="#4-2-记忆的演化：一致且变化的认知与对人类的模拟" class="headerlink" title="4.2 记忆的演化：一致且变化的认知与对人类的模拟"></a>4.2 记忆的演化：一致且变化的认知与对人类的模拟</h3><p><strong>记忆形成</strong>过程负责从原始数据中提取记忆。而下一步的关键环节，是将新提取的记忆与已有记忆库进行整合，从而实现记忆系统的<strong>动态演化</strong>。</p>
<blockquote>
<p>一种简单直接的策略是将新的记忆条目直接追加至已有记忆库中，但这种方式既忽略了记忆条目之间的语义关联与潜在矛盾，也未考虑信息的时效性。为解决这些局限性，<strong>记忆演化</strong>机制通过整合新旧记忆、提炼高层级洞察、消解逻辑冲突、剔除过时数据，保障了长期知识的简洁性、一致性与关联性，使记忆系统能够随着环境与任务的变化，动态适配自身的认知过程与上下文理解能力。</p>
</blockquote>
<p><strong>记忆演化三种核心机制</strong></p>
<table>
<thead>
<tr>
<th>核心机制</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>记忆整合</strong><br />Memory Consolidation</td>
<td>融合新旧记忆并执行反思性整合，形成更具泛化性的洞察。这一过程确保智能体的学习是<strong>累积式</strong>而非孤立式的。</td>
</tr>
<tr>
<td><strong>记忆更新</strong><br />Memory Updating</td>
<td>消解新旧记忆之间的冲突，对记忆库进行修正与补充，以维持其准确性与关联性。该机制使智能体能够适应环境变化或任务需求的调整。</td>
</tr>
<tr>
<td><strong>记忆遗忘</strong><br />Memory Forgetting</td>
<td>移除过时或冗余的信息，释放存储空间并提升系统效率。这一操作可避免因知识过载导致的性能下降，确保记忆库始终聚焦于具备可操作性的实时知识。</td>
</tr>
</tbody></table>
<p>上述机制共同维护了记忆库的<strong>泛化性、准确性与时效性</strong>。通过对记忆演化的主动管理，这些机制充分凸显了记忆系统的智能体特性，为持续学习与自主迭代优化提供了有力支撑。</p>
<h4 id="4-2-1-记忆整合：形成高级且完整的知识图景"><a href="#4-2-1-记忆整合：形成高级且完整的知识图景" class="headerlink" title="4.2.1 记忆整合：形成高级且完整的知识图景"></a>4.2.1 记忆整合：形成高级且完整的知识图景</h4><blockquote>
<p>记忆整合的目标是将新获取的短期记忆轨迹转化为<strong>结构化、可泛化的长期知识</strong>。其核心机制是识别新记忆与已有记忆之间的语义关联，并将二者整合为更高级别的抽象概念或洞察。这一过程主要实现两大目的：第一，将碎片化的信息重组为连贯的结构，避免关键细节在短期记忆阶段流失，进而促成稳定知识框架的形成；第二，通过对经验数据进行抽象、压缩与泛化，从具体事件中提炼出可复用的模式，生成能够支撑跨任务泛化的洞察。</p>
</blockquote>
<p>记忆整合的核心挑战在于<strong>确定新记忆与已有记忆匹配、融合的粒度</strong>。现有研究涵盖了多种整合策略，范围从局部内容的合并，延伸到聚类级别的融合，再到全局层面的整合。</p>
<p><strong>局部整合</strong></p>
<ul>
<li>聚焦于针对<strong>高度相似的记忆片段</strong>进行细粒度更新。比如，每条新生成的主题记忆都会检索与之最相似的前 K 个候选记忆，再由大语言模型判断是否适宜合并，以此降低不当泛化的风险。在多模态场景下，当内存容量趋于饱和时，识别出最相似或冗余的记忆对，并将其压缩为更高级别的抽象表征。</li>
<li>这类方法在保留记忆库全局结构的同时，优化了细节知识，提升了记忆的精准度与存储效率。但它们无法完整捕捉<strong>聚类级别的关联</strong>，也难以挖掘语义相关记忆之间存在的高阶依赖关系。</li>
</ul>
<p><strong>聚类级融合</strong></p>
<p>随着记忆规模的增长，采用聚类级融合策略对于捕捉跨实例规律至关重要。</p>
<ul>
<li>在<strong>跨聚类层面</strong>，将新生成的记忆聚类与已有相似聚类进行对齐，并采用泛化、细化等融合模式，构建更高级别的推理单元，大幅提升了记忆的可解释性与推理深度。</li>
<li>在<strong>聚类内层面</strong>，对存在语义冗余的条目进行合并，将目标聚类内的所有节点融合为一条具有代表性的摘要，生成更高级别且跨样本一致的记忆表征。</li>
</ul>
<p>这类方法在更宏观的尺度上重组记忆结构，是构建结构化知识的关键一步。</p>
<p><strong>全局整合</strong></p>
<p>该操作执行<strong>整体性整合</strong>，旨在维持记忆的全局连贯性，并从累积的经验中提炼出系统级洞察。语义摘要侧重于从现有上下文生成全局摘要，可视为摘要的初步构建；而当新信息持续输入时，重要的是如何将其整合至已有的全局摘要中。</p>
<ul>
<li>针对<strong>用户事实性记忆</strong>，MOOM 结合基于规则的处理方法、嵌入技术与大语言模型驱动的抽象机制，将临时的用户角色快照与历史轨迹相整合，构建出稳定的用户角色画像。</li>
<li>针对<strong>经验性记忆</strong>，Matrix 通过迭代优化，将任务执行轨迹与反思性洞察融入全局记忆，提炼出与任务无关的通用原则，以支持跨场景复用。</li>
</ul>
<p>全局整合从完整的经验历史中提炼出<strong>高级结构化知识</strong>，既为推理提供了稳定的上下文基础，又提升了模型的泛化能力、推理准确率与个性化决策水平。</p>
<p><strong>记忆整合是将碎片化的短期记忆轨迹重组为连贯长期知识框架的认知过程。它超越了简单的存储功能，主动建立孤立记忆条目之间的关联，形成结构化的认知图景。<strong>该机制不仅增强了模型的泛化能力，还降低了存储冗余。但记忆整合也存在</strong>信息平滑</strong>的风险：在抽象过程中，异常事件或独特特例可能会被忽略，进而削弱智能体对异常情况与特定事件的敏感度。</p>
<h4 id="4-2-2-记忆更新：始终保持一致的自我"><a href="#4-2-2-记忆更新：始终保持一致的自我" class="headerlink" title="4.2.2 记忆更新：始终保持一致的自我"></a>4.2.2 记忆更新：始终保持一致的自我</h4><blockquote>
<p><strong>记忆更新</strong>指的是智能体在遭遇记忆冲突或获取新信息时，对已有记忆进行修正或替换的过程。其目标是在无需对模型进行全量重训的前提下，维持记忆的事实一致性并支持持续适配。与<strong>聚焦于抽象与泛化</strong>的记忆整合不同，记忆更新强调<strong>局部修正与同步</strong>，使智能体能够与动态演化的环境保持一致。</p>
</blockquote>
<p>通过持续更新，智能体记忆系统可保障知识的准确性与时效性，避免过时信息对推理过程产生偏差。因此，记忆更新是实现<strong>终身学习与自主演化</strong>的核心机制。根据记忆的存储位置，更新方式可分为两类：（1）<strong>外部记忆更新</strong>：对外部记忆存储模块的更新；（2）<strong>模型编辑</strong>：在模型参数空间内进行的内部编辑操作。</p>
<p><strong>外部记忆更新</strong></p>
<ul>
<li><p>当出现记忆冲突或新事实时，需对向量数据库或知识图谱中的记忆条目进行修正。该方法无需修改模型权重，而是通过动态调整外部存储内容来维持事实一致性。静态存储的记忆不可避免地会累积过时或冲突条目，进而引发逻辑矛盾与推理错误。外部记忆更新支持轻量化修正，同时规避了全量重训或重新索引的高昂成本。</p>
</li>
<li><p>外部记忆更新机制的发展历经了多个阶段，从<strong>基于规则的修正</strong>逐步演进为<strong>时间感知的软删除</strong>、<strong>延迟一致性策略</strong>，最终发展为<strong>全学习驱动的更新策略</strong>。总体而言，外部记忆更新已从人工触发的修正操作，演进为具备自调节能力、时间感知能力的学习过程，通过大语言模型驱动的检索、冲突检测与修正，实现事实一致性与结构稳定性的双重保障。</p>
</li>
</ul>
<p><strong>模型编辑</strong></p>
<ul>
<li><strong>模型编辑</strong>指的是在模型参数空间内直接执行修改操作，以此修正或注入知识，且无需对模型进行全量重训，属于<strong>隐式知识更新</strong>。全量重训不仅成本高昂，还容易引发灾难性遗忘。模型编辑支持精准、低成本的知识修正，有效提升模型的适应性与内部知识留存能力。</li>
<li>模型编辑方法主要分为两类：显式定位与修改，与隐空间自主更新。</li>
</ul>
<p>从实现逻辑来看，记忆更新的核心是<strong>基于新记忆的触发，解决冲突并修正知识</strong>；而记忆整合则侧重于<strong>新旧知识的融合与抽象</strong>。上述两种记忆更新策略构建了一套<strong>双路径机制</strong>：涵盖外部数据库的冲突消解与模型内部的参数编辑，使智能体能够实现持续的自我修正，为长期演化提供支撑。</p>
<p>记忆更新面临的核心挑战是<strong>稳定性 - 可塑性困境</strong>：即如何界定 “覆盖已有知识” 与 “将新信息判定为噪声” 的边界。不当的更新操作可能覆盖关键信息，进而导致知识退化与推理失效。</p>
<h4 id="4-2-3-记忆遗忘：对人类记忆的模拟"><a href="#4-2-3-记忆遗忘：对人类记忆的模拟" class="headerlink" title="4.2.3 记忆遗忘：对人类记忆的模拟"></a>4.2.3 记忆遗忘：对人类记忆的模拟</h4><p>**基于时间的衰减机制模拟记忆的自然时效衰减，基于频率的遗忘机制保障高频记忆的高效访问，基于重要性的遗忘机制则赋予系统语义层面的辨别能力。**这三类遗忘机制共同调控智能体记忆的时效性、检索效率与语义关联性。</p>
<blockquote>
<p><strong>记忆遗忘</strong>是指主动移除过时、冗余或低价值的信息，从而释放存储空间，确保记忆聚焦于关键知识。与用于消解记忆冲突的更新机制不同，遗忘机制的核心是剔除过时信息，保障记忆系统的效率与关联性。随着时间推移，无限制的记忆累积会导致噪声增加、检索延迟延长，还会受到过时知识的干扰。<strong>可控遗忘</strong>有助于缓解记忆过载问题，维持系统的认知聚焦。但过度激进的记忆修剪可能会清除那些出现频率低但至关重要的知识，损害智能体在长期任务场景下的推理连贯性。</p>
</blockquote>
<p>遗忘机制可分为三类：<strong>基于时间的遗忘</strong>、<strong>基于频率的遗忘</strong>和<strong>基于重要性的遗忘</strong>，分别对应记忆的创建时间、检索活跃度以及综合语义价值这三个维度。</p>
<ul>
<li><p><strong>基于时间的遗忘</strong>：基于时间的遗忘机制仅以记忆的创建时间为依据，通过随时间推移逐步降低记忆强度，模拟人类记忆的自然衰减过程。</p>
</li>
<li><p><strong>基于频率的遗忘</strong>：基于频率的遗忘机制根据记忆的检索行为确定优先级，保留被高频访问的记忆条目，同时剔除长期未被调用的内容。基于时间的衰减机制捕捉记忆的自然时效性老化，基于频率的遗忘机制反映记忆的使用动态，二者从两个独立维度构建了更全面的遗忘分类体系，共同维持系统的运行效率与记忆时效性。</p>
</li>
<li><p><strong>基于重要性的遗忘</strong>：基于重要性的遗忘机制融合时间、频率与语义信号，在保留高价值知识的同时修剪冗余内容。随着大语言模型判断能力的不断增强，直接利用大语言模型评估记忆的重要性，并显式地修剪或遗忘次要记忆。这一转变标志着遗忘机制从<strong>静态数值评分</strong>向<strong>语义智能判断</strong>的跨越。如今，智能体已能够执行<strong>自主选择性遗忘</strong>，精准保留与任务上下文、语义内容及情感线索高度相关的记忆。</p>
</li>
</ul>
<p><em>前文所述的研究均聚焦于人工设计不同阶段的记忆架构，从而支持智能体记忆内容的在线演化。而近期提出的 MemEvolve 构建了一种*<em>元演化框架</em></em>，能够同时驱动智能体的经验知识与底层记忆架构协同演化，使记忆框架本身具备持续学习与自主适配的能力。*</p>
<h3 id="4-3-记忆检索"><a href="#4-3-记忆检索" class="headerlink" title="4.3 记忆检索"></a>4.3 记忆检索</h3><blockquote>
<p>在恰当的时机，从特定记忆库中调取相关且精炼的知识片段，为当前推理任务提供支撑的过程。这一过程的核心挑战是，如何在大规模记忆库中高效、精准地定位所需的知识片段。为应对这一挑战，诸多算法采用启发式策略或可学习模型，对检索流程的各个阶段进行优化。</p>
</blockquote>
<p><strong>记忆检索的四大环节</strong></p>
<table>
<thead>
<tr>
<th>环节</th>
<th>核心</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>检索时机与意图</strong><br />Retrieval Timing and Intent</td>
<td>何时何处进行检索</td>
<td>确定触发记忆检索的具体时机与目标，实现从被动的、指令驱动的触发模式，向自主的、自我调控的决策模式转变。</td>
</tr>
<tr>
<td><strong>查询构建</strong><br />Query Construction</td>
<td>要检索什么内容</td>
<td>通过对用户原始输入进行分解或改写，生成有效的检索信号，以此弥合用户原始输入与记忆库索引之间的语义鸿沟。</td>
</tr>
<tr>
<td><strong>检索策略</strong><br />Retrieval Strategies</td>
<td>聚焦如何执行检索</td>
<td>在记忆库中执行检索操作，所采用的技术范式涵盖稀疏词汇匹配、稠密语义嵌入，以及具备结构感知能力的图谱遍历等。</td>
</tr>
<tr>
<td><strong>检索后处理</strong><br />Post-Retrieval Processing</td>
<td>如何整合与使用</td>
<td>通过重排序、过滤与聚合等操作，对检索得到的原始知识片段进行优化，确保最终提供给模型的上下文信息简洁且连贯。</td>
</tr>
</tbody></table>
<p>上述机制共同作用，将记忆检索从一项静态的搜索操作，转变为一个动态的认知过程。一个稳健的智能体系统，通常会在统一的流程框架内协调这些组件，使智能体能够实现类人的联想记忆激活机制，从而高效地获取知识。</p>
<h4 id="4-3-1-检索时机与意图"><a href="#4-3-1-检索时机与意图" class="headerlink" title="4.3.1 检索时机与意图"></a>4.3.1 检索时机与意图</h4><blockquote>
<p>检索意图与检索时机决定了<strong>何时触发检索机制</strong>以及<strong>查询哪个记忆存储模块</strong>。现有记忆系统在此方面采用了不同的设计方案，检索模式既可以是持续开启的，也可以是由显式指令或内部信号触发的。</p>
</blockquote>
<ul>
<li><p><strong>自动化检索时机</strong>：模型在推理过程中，自主判断何时触发记忆检索操作的能力。最简单的策略是将决策权限交由大语言模型（LLM）或外部控制器，使其仅根据查询内容判断是否需要执行检索。但此类方法仅依赖查询内容进行静态判断，忽略了模型在推理过程中<strong>动态变化的认知状态</strong>。为解决这一局限性，近期研究将<strong>快慢思维机制</strong>融入检索时机的设计中。</p>
</li>
<li><p><strong>自动化检索意图</strong>：在层级化的存储结构中，模型自主决定访问哪个记忆源的能力。但该方法依赖显式反馈信号，在开放式推理场景中的适用性受到限制。</p>
</li>
</ul>
<p>自主化的检索时机与检索意图有助于降低计算开销、抑制无关噪声，但同时也存在潜在隐患。当智能体过度依赖内部知识储备，在需要检索外部记忆时却未能触发相应操作，系统便会陷入<strong>隐性失效模式</strong>—— 此时的知识缺口可能会导致生成幻觉化输出。</p>
<p>因此，需要在两者之间实现一种平衡：既要在恰当的时机为智能体提供关键信息，又要避免因过度检索而引入额外噪声。</p>
<h4 id="4-3-2-查询构建"><a href="#4-3-2-查询构建" class="headerlink" title="4.3.2 查询构建"></a>4.3.2 查询构建</h4><blockquote>
<p>将原始查询转化为与<strong>记忆索引</strong>相匹配的有效检索信号。查询构建充当了用户表层表述与记忆潜在存储形式之间的<strong>转换层</strong>。传统方法通常直接基于用户查询执行检索，该方式虽简单易行，却无法实现查询语义与记忆索引语义的对齐。为消除这一鸿沟，智能体记忆系统会主动执行<strong>查询分解</strong>或<strong>查询重写</strong>操作，生成更贴合记忆潜在结构的中间检索信号。</p>
</blockquote>
<ul>
<li><p><strong>查询分解</strong>：该方法将复杂查询拆解为若干简单子查询，使系统能够检索到更细粒度、更具相关性的信息。这种分解策略通过支持对中间结果的模块化检索与推理，有效缓解了 “一次性检索” 的瓶颈问题。然而，这些方法仍以问题驱动的分解为主，无法显式识别模型缺失的具体知识。</p>
</li>
<li><p><strong>查询重写</strong>：该策略不进行查询分解，而是在检索前对原始查询进行改写，或生成一份<strong>假设文档</strong>以优化其语义表达。这种重写操作能够缓解用户意图与记忆索引之间的匹配错位问题。</p>
</li>
</ul>
<p><strong>分解与重写这两种范式并非互斥关系。<strong>与早期研究侧重于设计复杂的记忆架构不同，近期的相关研究越来越重视检索构建流程，将记忆的角色逐步转向</strong>服务于检索需求</strong>。毫无疑问，检索查询的构建方式选择，是整个记忆检索流程中的关键环节。</p>
<h4 id="4-3-3-检索策略"><a href="#4-3-3-检索策略" class="headerlink" title="4.3.3 检索策略"></a>4.3.3 检索策略</h4><blockquote>
<p>核心挑战在于如何利用该查询语句，从规模庞大且结构复杂的记忆库中<strong>高效、精准地检索出真正相关的知识</strong>。检索策略是连接查询语句与记忆库的桥梁，其设计方案直接决定检索效率与结果质量。</p>
</blockquote>
<p><strong>词汇检索</strong></p>
<p>该策略依靠关键词匹配定位相关文档，代表性方法包括<strong>词频 - 逆文档频率算法（TF-IDF）</strong>。TF-IDF 基于词频和逆文档频率衡量关键词的重要性，可实现快速且可解释的检索。BM25 则进一步优化该方法，融入了词频饱和效应与文档长度归一化机制。此类方法常用于<strong>精度优先的检索场景</strong>，即优先保证结果的准确性与相关性，而非召回率。但纯词汇匹配难以捕捉语义变体与上下文关联，对语言表达差异高度敏感，因此在开放域知识或多模态记忆场景中效果欠佳。</p>
<p><strong>语义检索</strong></p>
<p>该策略将查询语句与记忆条目编码至同一个共享嵌入空间，基于<strong>语义相似度而非词汇重叠度</strong>进行匹配。代表性方法采用语义编码器，例如<strong>句级双向编码器表示模型（Sentence-BERT）<strong>与</strong>对比语言 - 图像预训练模型（CLIP）</strong>。在记忆系统中，该方法能更好地捕捉任务上下文，支持语义泛化与模糊匹配，因此成为大多数智能体记忆框架的默认选择。但<strong>语义漂移</strong>与<strong>强制的前 K 项检索</strong>往往会引入检索噪声与虚假召回结果。为解决这些问题，近期的系统融入了动态检索策略、重排序模块与混合检索方案。</p>
<p><strong>图检索</strong></p>
<p>该策略不仅利用语义信号，还借助图的显式拓扑结构，实现本质上更精准、具备结构感知能力的检索。通过直接访问结构化路径，此类方法展现出更强的<strong>多跳推理能力</strong>，能更有效地挖掘长距离依赖关系。此外，将关系结构作为推理路径的约束条件，可自然支持基于精确规则与符号约束的检索。</p>
<p><strong>生成式检索</strong></p>
<p><strong>该策略摒弃词汇或语义检索的思路，采用模型直接生成相关文档标识符的方式实现检索。<strong>通过将检索任务构建为条件生成任务，模型会将候选文档隐式存储于自身参数中，并在解码阶段执行查询 - 文档的深度交互。借助预训练语言模型的语义能力，该范式的性能往往优于传统检索方法，在</strong>小规模场景</strong>中表现尤为突出。但生成式检索需要额外训练以内化所有候选文档的语义信息，当文档库不断更新时，其可扩展性会受到限制。正因如此，智能体记忆系统对该范式的关注相对较少，不过其将生成与检索深度融合的特性，蕴含着尚未被挖掘的潜力。</p>
<p><strong>混合检索</strong></p>
<p>该策略整合多种检索范式的优势。例如，Agent KB 与 MIRIX 将词汇检索与语义检索相结合，在精准的术语或工具匹配与更广泛的语义对齐之间取得平衡。同理，<strong>语义锚定技术（Semantic Anchoring）</strong> 。同时对语义嵌入向量与符号倒排索引执行并行搜索，实现互补性的检索覆盖。还有部分方法融合多种评估信号以指导检索过程，例如<strong>生成式智能体（Generative Agents）</strong> 采用一种评分机制，综合考量信息的时效性、重要性与相关性，便是这种多因素检索方法的典型案例。MAICC 则采用混合效用评分函数，整合全局相似度与预测个体反馈的相似度。在基于图的检索场景中，检索流程通常分为两个阶段：先通过语义检索识别相关节点或三元组，再利用图拓扑结构扩展搜索空间。</p>
<p>在数据库基础设施层面，<strong>记忆数据库（MemoriesDB）</strong> 提出一种面向智能体长期记忆的<strong>时序 - 语义 - 关系型数据库</strong>，提供混合检索架构，将这三个维度整合至统一的存储与访问框架中。</p>
<p>通过融合异构检索信号，混合检索方法既保留了关键词匹配的精度，又融入了语义方法的上下文理解能力，最终能够输出更全面、更具相关性的检索结果。</p>
<h4 id="4-3-4-检索后处理"><a href="#4-3-4-检索后处理" class="headerlink" title="4.3.4 检索后处理"></a>4.3.4 检索后处理</h4><blockquote>
<p>初始检索返回的结果往往存在冗余、含噪或语义不一致的问题。若直接将这类结果注入提示词，会导致上下文过长、信息冲突，还会让推理过程被无关内容干扰。因此，<strong>检索后处理</strong>成为保障提示词质量的关键环节，其目标是将检索结果提炼为<strong>简洁、准确且语义连贯的上下文</strong>。在实际应用中，该环节包含两个核心模块：</p>
<p>（1）<strong>重排序与过滤</strong>：通过细粒度的相关性评估，剔除无关或过时的记忆，并对剩余片段重新排序，从而降低噪声与冗余度；</p>
<p>（2）<strong>聚合与压缩</strong>：将检索到的记忆与原始查询整合，消除重复内容、合并语义相似信息，最终构建出紧凑且连贯的上下文。</p>
</blockquote>
<p><strong>重排序与过滤</strong></p>
<p>为构建简洁连贯的上下文，需对初始检索结果执行重排序与过滤操作，移除低相关性内容。早期方法依赖启发式准则评估语义一致性，但这类方法通常需要大量超参数调优，才能平衡不同维度的重要性评分。</p>
<p><strong>聚合与压缩</strong></p>
<p>检索后处理的另一核心方向是聚合与压缩，旨在提升下游推理任务的质量与效率。该过程将检索到的证据与原始查询整合，形成连贯紧凑的上下文。与主要解决噪声和排序问题的过滤、重排序不同，聚合与压缩阶段侧重于<strong>将碎片化的记忆条目融合为更高层次的精炼知识表征</strong>，并根据特定任务需求对这些表征进行优化。</p>
<p>**检索后处理是衔接原始检索结果与推理环节的关键中间步骤，它能将杂乱、碎片化的检索数据转化为精准、连贯的推理上下文。**借助上述机制，检索后处理不仅提升了输入模型的记忆信息密度与保真度，还能让信息与任务需求、智能体特性实现精准匹配。</p>
<h2 id="五、新兴前沿"><a href="#五、新兴前沿" class="headerlink" title="五、新兴前沿"></a>五、新兴前沿</h2><p>本节阐述<strong>基于大语言模型的智能体记忆系统设计</strong>中的核心研究立场与新兴前沿方向。本文突破对现有方法的描述性综述范畴，聚焦于能<strong>重新定义长周期智能体场景下记忆构建、管理与优化方式</strong>的范式级变革。具体而言，我们将探讨记忆系统从<strong>检索中心模式向生成式模式</strong>、从<strong>人工设计架构向自主管理架构</strong>、从<strong>启发式流程向强化学习驱动的记忆控制</strong>的转型过程。本文进一步论述这些变革如何与多模态推理、多智能体协作及可信性等研究方向交叉融合，并梳理出有望塑造下一代智能体记忆架构的开放性挑战与研究方向。</p>
<h3 id="5-1-记忆检索与记忆生成"><a href="#5-1-记忆检索与记忆生成" class="headerlink" title="5.1 记忆检索与记忆生成"></a>5.1 记忆检索与记忆生成</h3><blockquote>
<p>在智能体记忆研究的发展历程中，<strong>记忆检索</strong>长期占据主导范式。该范式的核心目标是，结合当前上下文，从已有的记忆库中识别、筛选并提取最相关的记忆条目。未来，生成式方法将在智能体记忆系统中占据越来越核心的地位。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p>在智能体记忆研究的发展历程中，<strong>记忆检索</strong>长期占据主导范式。该范式的核心目标是，结合当前上下文，从已有的记忆库中识别、筛选并提取最相关的记忆条目。大量早期研究致力于通过优化索引策略、相似度计算指标、重排序模型，或是采用知识图谱这类结构化表征形式，来提升检索的准确率。</p>
<p>然而，近年来研究的关注点逐渐向<strong>记忆生成</strong>转移。记忆生成范式不再将记忆视为一个供查询调用的静态存储库，而是强调智能体<strong>根据需求主动合成新记忆表征</strong>的能力。其目标并非简单地检索并拼接现有记忆片段，而是基于当前上下文与未来应用价值，对信息进行整合、压缩与重组。这种范式转型背后，是学界逐渐形成的一种共识：<strong>高效的记忆应用往往需要对信息进行抽象与重构，尤其是当存储的原始信息存在噪声、冗余，或与当前任务需求不匹配时。</strong></p>
<p><strong>【当下】</strong></p>
<p>当前的记忆生成方法大致可分为两大研究方向。</p>
<p>**第一类采用 “先检索，后生成”的策略，即将检索到的记忆条目作为重构的原始素材。**在该框架下，智能体首先调取部分相关记忆，再生成一份更简洁、连贯且贴合具体场景的精炼记忆表征。</p>
<ul>
<li>ComoRAG、G-Memory 与 CoMEM 等系统均采用了这一思路。这种方法既保留了记忆与历史信息的关联性，又能实现自适应的摘要生成与结构重组。</li>
</ul>
<p>**第二类研究方向则探索直接生成式记忆 ，即无需显式的检索步骤，直接生成记忆内容。**智能体可基于当前上下文、交互历史或内部隐状态，直接生成记忆表征。</p>
<ul>
<li>MemGen 与 VisMem 等系统是该方向的典型代表 —— 它们通过构建适配当前任务的隐式记忆表征单元，完全绕开了显式的记忆查询流程。</li>
</ul>
<p><strong>【未来】</strong></p>
<p>理想的下一代生成式记忆机制应具备以下三项关键特性：</p>
<p>第一，<strong>生成式记忆需具备上下文自适应性</strong>。</p>
<p>记忆系统不应存储通用化的摘要内容，而应生成针对智能体<strong>预期未来需求</strong>进行优化的记忆表征。这包括根据不同的任务类型、问题求解阶段或交互场景，动态调整记忆的粒度、抽象层级与语义侧重点。</p>
<p>第二，<strong>生成式记忆需支持异构信号的融合能力</strong>。</p>
<p>智能体的运行越来越依赖多样化的模态与信息源，涵盖文本、代码、工具输出及环境反馈等。记忆生成机制为将这些碎片化的信号融合为统一表征提供了天然路径，相较于简单的内容拼接或单一检索，这种统一表征对下游推理任务的价值更高。我们推测，<strong>隐式记忆</strong>（详见 3.3 节）或将成为实现这一目标的极具潜力的技术路线。</p>
<p>第三，<strong>生成式记忆需具备可学习性与自优化能力</strong>。</p>
<p>未来的记忆系统不应依赖人工预设的生成规则，而应通过强化学习、长周期任务性能表现等优化信号，自主学习记忆生成的时机与方式。从这个角度来看，记忆生成将成为智能体决策策略的有机组成部分，与推理、决策过程协同演进。</p>
<h3 id="5-2-自动化记忆管理：从人工设计到自主构建的记忆系统"><a href="#5-2-自动化记忆管理：从人工设计到自主构建的记忆系统" class="headerlink" title="5.2 自动化记忆管理：从人工设计到自主构建的记忆系统"></a>5.2 自动化记忆管理：从人工设计到自主构建的记忆系统</h3><blockquote>
<p>现有的智能体记忆系统通常依赖<strong>人工设计的策略</strong>来决定存储哪些信息、何时调用信息以及如何更新或检索信息。而自适应、自组织的记忆架构，将为构建具备稳健、可扩展且真正自主的记忆管理能力的智能体奠定基础。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p>现有的智能体记忆系统通常依赖<strong>人工设计的策略</strong>来决定存储哪些信息、何时调用信息以及如何更新或检索信息。系统设计者通过详细指令、预定义阈值或由领域专家编写的显式人工规则来引导固定的大语言模型，能够以相对较低的计算与工程成本将记忆模块集成到现有智能体框架中，实现快速的原型开发与部署。此外，这类系统还具备良好的可解释性、可复现性与可控性，开发者能够精准定义记忆的状态与行为模式。</p>
<p>但与其他领域的专家系统类似，这类人工构建的方案存在显著局限性：其本质上缺乏灵活性，往往难以在多样、动态的环境中实现泛化，因此在长期或开放式交互场景中容易表现不佳。</p>
<p><strong>【当下】</strong></p>
<p>近年来，智能体记忆研究的新进展正着手解决上述局限，致力于让智能体<strong>自主管理记忆的演化与检索过程</strong>。</p>
<ul>
<li>CAM 赋予大语言模型智能体自动将细粒度记忆条目聚类为高层抽象单元的能力；</li>
<li>Memory-R1 则引入一个配备专用 “记忆管理器” 工具的辅助智能体，专门负责处理记忆更新任务。</li>
</ul>
<p><strong>【未来】</strong></p>
<p><strong>通过显式的工具调用机制，将记忆构建、演化与检索过程直接融入智能体的决策循环</strong>。</p>
<ul>
<li>让智能体自主对记忆操作进行推理决策，而非依赖外部模块或人工预设的工作流程。</li>
<li>与现有将智能体内在推理过程和记忆管理操作相分离的设计方案不同，基于工具调用的策略能让大语言模型智能体清晰地感知自身执行的记忆操作（如添加 &#x2F; 更新 &#x2F; 删除 &#x2F; 检索），从而实现更连贯、透明且贴合上下文的记忆行为。</li>
</ul>
<p><strong>具备层级化与自适应架构的自优化记忆结构</strong>。</p>
<ul>
<li>首先，已有研究证明层级化记忆结构能够提升记忆系统的效率与性能。</li>
<li>除层级化设计外，具备动态链接、索引与重构记忆条目能力的<strong>自演化记忆系统</strong>，可使记忆存储本身随时间推移实现自组织，进而支持更复杂的推理任务，并降低对人工设计规则的依赖。</li>
</ul>
<h3 id="5-3-强化学习与智能体记忆的结合：强化学习正在让智能体内化记忆管理能力"><a href="#5-3-强化学习与智能体记忆的结合：强化学习正在让智能体内化记忆管理能力" class="headerlink" title="5.3 强化学习与智能体记忆的结合：强化学习正在让智能体内化记忆管理能力"></a>5.3 强化学习与智能体记忆的结合：强化学习正在让智能体内化记忆管理能力</h3><blockquote>
<p>未来的记忆将不再是附加在大语言模型智能体上的辅助机制，而是一个完全可学习、具备自组织能力的子系统，并通过强化学习与智能体协同演进。这类系统有望使人工智能体真正实现持续学习，并具备长期任务胜任能力。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p>强化学习正迅速重塑现代大语言模型智能体的发展范式。在规划、推理、工具调用等各类智能体核心能力领域，以及数学推理、深度研究、软件工程等多样任务场景中，强化学习均已开始成为驱动智能体性能提升的核心技术。记忆作为智能体能力的基础组件之一，也遵循着从<strong>流水线驱动范式向模型原生范式</strong>演进的相似趋势。智能体记忆研究领域正逐步从早期的启发式设计与人工工程化方案，转向由强化学习主导关键决策的技术路线。展望未来，完全基于强化学习的记忆系统有望成为该领域的主流发展方向。</p>
<p>**前文综述的大部分智能体记忆相关研究，均可归类为无强化学习的记忆系统。**这类方法通常依赖启发式策略或人工预设的机制，例如：受遗忘曲线启发设计的固定阈值规则；采用的刚性语义检索流水线；或是用于存储记忆块的简单拼接策略。在部分系统中，大语言模型看似以智能体的方式参与记忆管理，但其底层行为完全由提示词驱动。模型仅被要求生成记忆条目，并未接受过针对高效记忆控制的专项训练。</p>
<p>这类方法在该领域的早期研究中占据主导地位，并且因其简单易用、实用性强的特点，在未来一段时间内仍可能保持影响力。</p>
<p><strong>【当下】</strong></p>
<p><strong>随着研究的深入，诸多工作开始将基于强化学习的方法融入记忆处理流水线的特定组件中。<strong>该方向的早期尝试是 RMM，该系统在基于 BM25 或其他语义相似度指标完成初始检索后，采用轻量级策略梯度学习器对记忆块进行排序。后续的系统则探索了更为宏大的设计方案。例如，Mem-α（Wang 等，2025p）将完整的记忆构建流程交由一个经强化学习训练的智能体负责，Memory-R1（Yan 等，2025c）也采用了类似的设计思路。一个快速发展的研究分支致力于探索智能体如何在超长多轮对话任务中自主对上下文进行折叠、压缩与管理，该场景对应的是</strong>工作记忆</strong>的管理问题（Kang 等，2025c；Ye 等，2025a）。该领域的诸多领先系统均采用强化学习训练，包括但不限于 Context Folding（Sun 等，2025b）、Memory-as-Action（Zhang 等，2025r）、MemSearcher（Yuan 等，2025a）以及 IterResearch（Chen 等，2025b）。这些强化学习辅助的方法已展现出强大的性能，也预示着强化学习在未来记忆系统设计中的作用将愈发重要。</p>
<p><strong>【未来】</strong></p>
<p>展望未来，我们认为<strong>完全由强化学习驱动的记忆系统</strong>将成为智能体记忆技术演进的下一个关键阶段。理想的此类系统应具备以下两项核心特性：</p>
<p><strong>智能体管理的记忆架构应最大限度减少对人工设计先验知识的依赖</strong></p>
<ul>
<li>现有诸多框架均借鉴了人类认知相关的设计模式，例如模拟大脑皮层或海马体的结构，或是将记忆预先划分为情景记忆、语义记忆、核心记忆等类别的层级化分类体系。尽管这些抽象设计对早期研究的开展起到了重要的支撑作用，但对于在复杂环境中运行的人工智能体而言，它们未必是最有效、最贴合其特性的结构。</li>
<li>在完全由强化学习驱动的模式下，智能体有望自主探索出全新且更适配的记忆组织方式，这类结构源于优化过程的动态演化，而非人类的主观直觉。从这个角度来说，可通过强化学习的激励机制，促使智能体自主设计新的记忆格式、存储方案或更新规则，从而构建出具备自适应性与创造性、而非人工定制的记忆架构。</li>
</ul>
<p><strong>未来的记忆系统应赋予智能体对记忆管理全流程的完整控制权</strong></p>
<ul>
<li>一个具备完全智能体特性的记忆系统，需要让智能体以一体化的方式自主处理多粒度记忆的形成、记忆的演化与记忆的检索任务。要实现这一程度的控制，几乎必然需要端到端的强化学习训练 —— 因为启发式方法或基于提示词的方法，无法在长周期任务中协调好这些组件之间复杂的交互关系。</li>
</ul>
<h3 id="5-4-多模态记忆"><a href="#5-4-多模态记忆" class="headerlink" title="5.4 多模态记忆"></a>5.4 多模态记忆</h3><blockquote>
<p>未来的核心挑战在于，设计出能够灵活适配多种模态的记忆表征与操作机制，同时确保不同模态信息间的语义对齐与时序一致性。此外，多模态记忆的发展不能止步于被动存储，还需进一步支持信息抽象、跨模态推理与长周期自适应等高级功能。攻克这些挑战，将是推动智能体在丰富的多模态环境中稳定、连贯运行的关键所在。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p>随着基于文本的记忆研究日趋成熟与深入，同时兼具多模态理解和生成能力的多模态大语言模型与统一模型持续发展，学术界的研究重心自然而然地延伸至<strong>多模态记忆</strong>领域。这一研究转向背后，是学界形成的普遍共识：现实世界中的智能体应用场景本质上是多模态的，仅支持文本形式的记忆系统，无法满足智能体在复杂环境下完成长周期推理与交互的需求。</p>
<p><strong>【当下】</strong></p>
<p><strong>让多模态智能体能够存储、检索并利用来自多样化感知输入的记忆</strong>。</p>
<p>该方向是智能体记忆研究的自然延伸 —— 因为在真实环境中运行的智能体，必然会接触到图像、音频、视频等各类非文本信号构成的异构数据源。</p>
<ul>
<li>多模态记忆的发展进度与对应模态技术的成熟度密切相关。其中，图像、视频等视觉模态受到了最多的关注，由此催生了大量针对视觉与视频记忆机制的研究成果，这些机制可支撑视觉定位、时序跟踪、长时场景一致性维护等任务。</li>
<li>相比之下，面向音频及其他模态的记忆系统研究仍处于相对未充分探索的阶段。</li>
</ul>
<p><strong>将记忆视为支撑统一模型的赋能组件</strong>。</p>
<p>在该研究范式下，记忆的主要作用并非辅助智能体决策，而是提升多模态生成任务的质量与一致性。例如，在图像和视频生成系统中，记忆机制常被用于维持实体一致性、保障多帧画面间的世界状态连贯，或是确保长序列生成过程的逻辑通顺。在这一应用场景中，记忆扮演的是一种 “稳定器” 角色，将生成内容锚定在已生成的信息之上，而非单纯记录智能体的交互经验。</p>
<p><strong>【未来】</strong></p>
<p>**展望未来，多模态记忆有望成为智能体系统中不可或缺的核心组件。**随着智能体的应用场景逐渐向具身化、交互式方向拓展，其信息来源将天然具备多模态属性，涵盖感知数据、动作反馈、环境交互信号等多个维度。因此，高效的记忆系统必须能够以统一的方式，实现对异构信号的存储、整合与检索。</p>
<h3 id="5-5-多智能体系统中的共享记忆：从孤立记忆到共享认知基底"><a href="#5-5-多智能体系统中的共享记忆：从孤立记忆到共享认知基底" class="headerlink" title="5.5 多智能体系统中的共享记忆：从孤立记忆到共享认知基底"></a>5.5 多智能体系统中的共享记忆：从孤立记忆到共享认知基底</h3><blockquote>
<p>随着多智能体系统越来越多地应用于开放式、多模态的环境中，共享记忆必须能够在对异构信号进行抽象整合的同时，维持时序连贯性与语义一致性。我们认为，<strong>隐式记忆</strong>是实现这一目标的极具前景的技术路径。沿着上述方向深入研究，对于推动共享记忆从单纯的协同辅助工具，升级为支撑稳健群体智能的核心基础，具有至关重要的意义。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p>随着基于大语言模型的多智能体系统（MAS）逐渐成为研究热点，共享记忆已发展为实现智能体间协同配合、行为一致性及群体智能的核心机制。早期的多智能体框架主要依赖<strong>孤立的本地记忆</strong>，并辅以显式的消息传递机制 —— 智能体通过对话历史或特定任务的通信协议来交换信息。这种设计虽能避免智能体之间的直接干扰，但往往存在信息冗余、上下文碎片化及通信开销过高的问题，且这些弊端会随着智能体团队规模扩大和任务周期延长而愈发突出。</p>
<p><strong>【当下】</strong></p>
<p>后续的研究工作引入了<strong>中心化的共享记忆结构</strong>，例如全局向量数据库、黑板系统或共享文档（洪等人，2024），可供所有智能体访问调用。这类设计构建出一种团队层级的记忆形式，能够支持智能体间的联合注意力聚焦，减少重复信息的产生，并为长周期任务的协同配合提供便利。</p>
<p>共享记忆可作为智能体开展规划制定、角色交接及共识达成的持久化公共认知基础。然而，这种简单直接的全局共享模式也带来了新的挑战，包括记忆内容杂乱冗余、写入操作冲突，以及缺乏基于角色或权限的访问控制机制等问题。</p>
<p><strong>【未来】</strong></p>
<p><strong>展望未来，共享记忆有望从被动的存储库，演进为可主动管理、具备自适应性的群体表征。</strong></p>
<p><strong>构建感知智能体属性的共享记忆</strong></p>
<p>根据智能体的角色分工、专业能力及信任等级，来约束其对共享记忆的读写行为，从而实现更结构化、更可靠的知识聚合。</p>
<p><strong>学习驱动的共享记忆管理。</strong></p>
<p>未来的系统无需依赖人工设计的策略来完成记忆同步、摘要生成或冲突解决等操作，而是可以通过训练，让智能体基于团队的长周期任务表现，自主决策共享记忆的贡献时机、内容及方式。</p>
<h3 id="5-6-面向世界模型的记忆机制"><a href="#5-6-面向世界模型的记忆机制" class="headerlink" title="5.6 面向世界模型的记忆机制"></a>5.6 面向世界模型的记忆机制</h3><blockquote>
<p>从架构层面来看，该领域正经历一场根本性变革 —— 从聚焦被动数据留存的<strong>数据缓存模式</strong>，转向聚焦主动状态维护的<strong>状态模拟模式</strong>。这一演进趋势正逐渐分化为两大明确范式，致力于解决实时响应性与长时序逻辑一致性之间的矛盾。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p>世界模型的核心目标是构建一个能够高保真模拟物理世界的<strong>内部环境</strong>。这类系统是支撑下一代人工智能技术发展的关键底层设施。世界模型的核心属性在于，其生成的内容兼具无限扩展性与实时交互性。</p>
<p>在这种迭代框架中，<strong>记忆机制</strong>是整个系统的基石。记忆负责存储和维护上一时间步的空间语义信息或隐状态，确保后续生成内容在场景布局、物体属性及运动逻辑等维度，与前文内容保持长期一致性。本质上，正是记忆机制让世界模型能够处理长时序依赖关系，实现高可信度的模拟交互。</p>
<p>早期的记忆建模方案依赖较为简单的缓冲机制。<strong>帧采样法</strong>以少量历史帧作为生成条件，该方法虽直观易懂，但会导致上下文碎片化与感知漂移，早期细节信息极易丢失。<strong>滑动窗口法</strong>借鉴了大语言模型的相关技术，例如注意力锚点与局部键值缓存，虽解决了计算瓶颈问题，却将记忆限制在固定窗口内。一旦物体移出该窗口，模型便会彻底 “遗忘”，无法完成闭环检测这类复杂任务。</p>
<p>【当下】</p>
<p>到 2025 年末，该领域的研究重心从有限上下文窗口转向了<strong>结构化状态表征</strong>。当前主流的架构方案主要分为三大类：</p>
<p><strong>状态空间模型架构</strong></p>
<p>长上下文状态空间模型等相关架构采用曼巴（Mamba）类网络作为基础骨干。这类模型将无限长的历史信息压缩为固定尺寸的递归状态，理论上可实现无限记忆容量，且推理成本保持恒定。</p>
<p><strong>显式记忆库</strong></p>
<p>与压缩状态的方案不同，这类系统维护一个存储历史表征的外部数据库，以支持精准的记忆召回。</p>
<p><strong>稀疏记忆与检索机制</strong></p>
<p>为平衡长时序一致性与计算效率，模型通过注入稀疏采样的历史帧，或检索与姿态相关的上下文信息来增强当前观测数据，从而锚定预测结果，避免操作任务过程中出现感知漂移。</p>
<p><strong>【未来】</strong></p>
<p><strong>双系统架构</strong></p>
<p>受认知科学启发，世界模型可被划分为 “快系统” 与 “慢系统” 两个部分。</p>
<ul>
<li>快系统：是快速响应、本能式的处理层，依托状态空间模型这类高效骨干网络，处理即时物理交互与流畅的动态反馈任务；</li>
<li>慢系统：是慢速思考、审慎决策的处理层，借助大尺度视觉语言模型或显式记忆数据库，完成复杂推理、任务规划与世界状态一致性维护工作。</li>
</ul>
<p><strong>主动记忆管理机制</strong></p>
<p>被动式记忆机制正逐步被主动记忆策略取代。</p>
<ul>
<li>新一代模型不再将记忆视为盲目存储近期历史数据的固定缓冲区，而是将其设计为认知工作空间 —— 根据任务相关性，主动对信息进行筛选、摘要与剔除。</li>
<li>在处理实际应用中的无限上下文场景时，这种主动记忆管理机制的性能显著优于静态检索方法。这一转变标志着技术路线的升级：从单纯记忆最近 N 个标记，进阶为维护一个连贯且可查询的世界状态。</li>
</ul>
<h3 id="5-7-可信记忆：从可信检索增强生成到可信记忆"><a href="#5-7-可信记忆：从可信检索增强生成到可信记忆" class="headerlink" title="5.7 可信记忆：从可信检索增强生成到可信记忆"></a>5.7 可信记忆：从可信检索增强生成到可信记忆</h3><blockquote>
<p>从长远来看，我们构想中的记忆系统将采用类操作系统的抽象架构：具备内存分段管理、版本控制、可审计的特性，并由智能体与用户共同管理。构建这样的系统，需要表征学习、系统设计与策略控制等多个领域的协同攻关。随着大语言模型智能体开始在持久化、开放式的环境中部署运行，可信记忆将不再只是一个锦上添花的功能特性，而是其走向实际应用的<strong>基础性要求</strong>。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p>早期围绕检索增强生成（RAG）系统中幻觉与事实性问题的担忧，如今已演变为针对记忆增强智能体的更广泛可信性研究议题。与检索增强生成技术类似，采用外部或长期记忆的一个主要目的，是通过将模型输出锚定在可检索的事实性内容上，从而减少幻觉现象的发生。但与检索增强生成不同的是，智能体记忆往往存储着用户专属、持久存在且可能涉及隐私的内容，涵盖事实性知识、过往交互记录、用户偏好乃至行为轨迹等多个方面。这就为记忆系统带来了隐私保护、可解释性与安全性层面的额外挑战。</p>
<ul>
<li>记忆模块可能会遭受基于提示词的间接攻击，进而导致隐私数据泄露，这一发现凸显了记忆系统存在的记忆固化与过度留存风险。</li>
<li><strong>可解释性</strong>同样是目前亟待突破的关键瓶颈。尽管文本日志、键值存储等显式记忆具备一定的透明性，但用户与开发者仍然缺乏有效工具，去追溯哪些记忆条目被检索调用、这些条目如何影响最终生成结果，以及它们是否被滥用。</li>
<li>在多智能体部署或跨组织协作的共享记忆、联邦记忆系统中，<strong>群体隐私保护</strong>的重要性正日益凸显。上述这些研究进展共同表明，有必要将 “可信性” 提升为记忆系统设计中的核心原则。</li>
</ul>
<p><strong>【未来】</strong></p>
<p>展望未来，我们认为可信记忆的构建必须围绕三大相互关联的核心支柱展开，即<strong>隐私保护、可解释性与抗幻觉能力</strong>，而每一个支柱的实现都需要架构与算法层面的创新突破。</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>隐私保护</td>
<td>未来的记忆系统应支持细粒度的权限管控记忆、用户自主管控的留存策略、加密存储或端侧存储方案，以及按需部署的联邦访问机制。</td>
</tr>
<tr>
<td>可解释性</td>
<td>研究需要突破 “仅展示可见内容” 的局限，实现可追溯的访问路径、具备自解释能力的检索机制，甚至支持反事实推理（例如：“如果没有这条记忆，结果会发生怎样的变化？”）。</td>
</tr>
<tr>
<td>幻觉缓解</td>
<td>冲突检测、多文档推理、不确定性感知生成等技术的持续发展将起到推动作用。在检索置信度较低时主动拒绝生成、回归模型先验知识、多智能体交叉校验等策略，均具有良好的应用前景。</td>
</tr>
</tbody></table>
<h3 id="5-8-与人类认知的关联"><a href="#5-8-与人类认知的关联" class="headerlink" title="5.8 与人类认知的关联"></a>5.8 与人类认知的关联</h3><blockquote>
<p>这一技术演进预示着记忆形态与功能的范式变革：从显式文本检索转向<strong>生成式记忆重构</strong>。未来的系统或将采用生成式记忆技术，让智能体能够按需合成隐式记忆标记，以此模拟人类大脑的记忆重构特性。通过整合类睡眠的记忆巩固周期，智能体将实现从 “数据归档工具” 到 “经验内化主体” 的跨越，通过周期性地将海量情景记忆压缩为高效的参数化直觉，最终解决记忆系统的 “稳定性 - 可塑性困境”。</p>
</blockquote>
<p><strong>【过去】</strong></p>
<p><strong>当代智能体记忆系统的架构设计，与过去一个世纪建立的人类认知基础模型逐渐趋同。</strong></p>
<p>当前主流的架构方案 —— 将容量受限的上下文窗口与大规模外部向量数据库相结合 —— 与<strong>阿特金森 - 谢夫林多重存储模型</strong>高度相似，相当于在人工系统中构建出了对应人类工作记忆与长时记忆的功能模块。此外，智能体记忆被划分为交互日志、世界知识与代码化技能这三类结构，与图尔文提出的情景记忆、语义记忆、程序记忆分类体系呈现出惊人的结构一致性。现有的诸多智能体框架，正是将这些源于人类生物学的记忆分类转化为工程实现方案：其中情景记忆保障智能体的 “自传式” 连续性，语义记忆则提供通用性的世界知识。</p>
<p><strong>尽管存在上述结构上的相似性，智能体记忆与人类记忆在检索和维护的动态机制上仍存在本质差异。</strong></p>
<p>人类的记忆是一个 “建设性” 的过程，大脑会基于当前的认知状态主动重构过往事件，而非简单回放精准的记录内容。相比之下，绝大多数现有智能体记忆系统依赖的是检索增强生成这类 “逐字检索” 机制，将记忆视为一个由不可变标记构成的存储库，仅通过语义相似度进行查询匹配。这就导致智能体虽然能够精准记录过往信息，却缺乏人类智能所特有的记忆扭曲、抽象归纳与历史动态重塑能力。</p>
<p><strong>【未来】</strong></p>
<p>为了弥合静态存储与动态认知之间的鸿沟，下一代智能体必须突破 “仅支持在线更新” 的局限，引入类似于生物睡眠机制的<strong>离线巩固机制</strong>。借鉴互补学习系统（CLS）理论，未来的智能体架构或将设置专门的 “记忆巩固时段”：在此期间，智能体暂时脱离与环境的交互，专注于记忆重组与生成式回放。借助这些离线阶段，智能体能够从原始的情景记忆轨迹中自主提炼出可泛化的知识图谱，通过主动遗忘剔除冗余噪声，并在摆脱实时处理延迟约束的前提下优化内部索引结构。</p>
<h2 id="六、结论：形式、功能与动态机制"><a href="#六、结论：形式、功能与动态机制" class="headerlink" title="六、结论：形式、功能与动态机制"></a>六、结论：形式、功能与动态机制</h2><p>在<strong>记忆形式</strong>层面，我们归纳出三种核心实现类型：标记级记忆、参数化记忆与隐式记忆。近年来，这三类记忆均取得了独特且快速的发展，它们在表征方式、适应性以及与智能体策略的集成度等方面，体现出本质不同的权衡取舍。</p>
<p>在<strong>记忆功能</strong>层面，我们突破了以往综述中广泛采用的 “长期记忆 - 短期记忆” 二元划分法，提出了一套更精细、更具包容性的分类体系 —— 根据记忆在知识留存、能力积累与任务级推理中承担的不同角色，将其划分为事实记忆、经验记忆与工作记忆。上述研究视角共同表明：记忆绝非单纯的辅助存储机制，而是智能体实现时序连贯性、持续适应性与长周期任务胜任力的<strong>核心基底</strong>。</p>
<p>除对已有研究进行系统性梳理外，本文还明确了智能体记忆研究迈向新阶段所面临的关键挑战与前沿方向。其中尤为关键的趋势包括：强化学习与记忆系统的深度融合、多模态及多智能体场景下记忆技术的兴起、从检索中心范式向生成式记忆范式的转型。这些趋势预示着未来的记忆系统将具备<strong>完全可学习、自适应、自组织</strong>的特性。此类系统有望推动大语言模型实现质的跨越 —— 从性能强大但功能固化的生成器，转变为能够持续交互、自主提升并开展严谨时序推理的智能体。</p>
<p>我们期望本综述能够为未来的相关研究奠定坚实且连贯的基础，同时为科研人员与工程实践者提供一份有价值的参考资料。随着智能体系统的持续发展成熟，记忆系统的设计将始终是一个核心且开放的研究课题，这一课题的突破，或将对稳健、通用、可持续的人工智能技术发展起到决定性作用。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石</p><p><a href="http://vincentgaohj.github.io/Blog/2026/01/19/Agent时代的记忆工程-从瞬时生成到持续存在的认知基石/">http://vincentgaohj.github.io/Blog/2026/01/19/Agent时代的记忆工程-从瞬时生成到持续存在的认知基石/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Haojun(Vincent) Gao</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2026-01-19</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2026-01-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-globe"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/Blog/tags/AWS/">AWS</a><a class="link-muted mr-2" rel="tag" href="/Blog/tags/Certified/">Certified</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=62145317b846610019d3dc05&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="https://afdian.net/@vincent_gaohj" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>Afdian.net</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/Blog/img/alipay.jpg" alt="Alipay"></span></a><a class="button donate" href="https://www.buymeacoffee.com/gaohaojun" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Blog/2026/01/06/AI%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E4%B9%8B-When-AI-Takes-the-Couch/"><span class="level-item">AI 模型的心理创伤：论文解读之《When AI Takes the Couch》</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://vincentgaohj.github.io/Blog/2026/01/19/Agent%E6%97%B6%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E5%B7%A5%E7%A8%8B-%E4%BB%8E%E7%9E%AC%E6%97%B6%E7%94%9F%E6%88%90%E5%88%B0%E6%8C%81%E7%BB%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AE%A4%E7%9F%A5%E5%9F%BA%E7%9F%B3/';
            this.page.identifier = '2026/01/19/Agent时代的记忆工程-从瞬时生成到持续存在的认知基石/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'vincentgaohj' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/Blog/2026/01/19/Agent%E6%97%B6%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E5%B7%A5%E7%A8%8B-%E4%BB%8E%E7%9E%AC%E6%97%B6%E7%94%9F%E6%88%90%E5%88%B0%E6%8C%81%E7%BB%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AE%A4%E7%9F%A5%E5%9F%BA%E7%9F%B3/"><img src="/Blog/gallery/AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4/big5.png" alt="Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石"></a></figure><div class="media-content"><p class="date"><time dateTime="2026-01-19T06:22:21.000Z">2026-01-19</time></p><p class="title"><a href="/Blog/2026/01/19/Agent%E6%97%B6%E4%BB%A3%E7%9A%84%E8%AE%B0%E5%BF%86%E5%B7%A5%E7%A8%8B-%E4%BB%8E%E7%9E%AC%E6%97%B6%E7%94%9F%E6%88%90%E5%88%B0%E6%8C%81%E7%BB%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%AE%A4%E7%9F%A5%E5%9F%BA%E7%9F%B3/">Agent 时代的记忆工程：从瞬时生成到持续存在的认知基石</a></p><p class="categories"><a href="/Blog/categories/AI/">AI</a> / <a href="/Blog/categories/AI/Research/">Research</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Blog/2026/01/06/AI%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E4%B9%8B-When-AI-Takes-the-Couch/"><img src="/Blog/gallery/AI%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4/big5.png" alt="AI 模型的心理创伤：论文解读之《When AI Takes the Couch》"></a></figure><div class="media-content"><p class="date"><time dateTime="2026-01-06T10:31:07.000Z">2026-01-06</time></p><p class="title"><a href="/Blog/2026/01/06/AI%20%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BF%83%E7%90%86%E5%88%9B%E4%BC%A4-%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%E4%B9%8B-When-AI-Takes-the-Couch/">AI 模型的心理创伤：论文解读之《When AI Takes the Couch》</a></p><p class="categories"><a href="/Blog/categories/AI/">AI</a> / <a href="/Blog/categories/AI/Research/">Research</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Blog/2025/12/20/AWS-Generative-AI-Developer-Professional-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2%E8%AF%A6%E8%A7%A3/"><img src="/Blog/gallery/AWS-Generative-AI-Developer-Professional-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2%E8%AF%A6%E8%A7%A3/AWS%20Certified%20Generative%20AI%20Developer%20-%20Professional.png" alt="AWS Certified Generative AI Developer - Professional (AIP-C01) 考试大纲详解"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-12-20T02:31:07.000Z">2025-12-20</time></p><p class="title"><a href="/Blog/2025/12/20/AWS-Generative-AI-Developer-Professional-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2%E8%AF%A6%E8%A7%A3/">AWS Certified Generative AI Developer - Professional (AIP-C01) 考试大纲详解</a></p><p class="categories"><a href="/Blog/categories/AWS/">AWS</a> / <a href="/Blog/categories/AWS/AWS-Certified-Generative-AI-Developer-Professional/">AWS Certified Generative AI Developer Professional</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Blog/2025/12/10/OpenRouter-%E7%9A%84-100-%E4%B8%87%E4%BA%BF-Tokens-%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/"><img src="/Blog/gallery/OpenRouter-100-Tokens/tokens.png" alt="OpenRouter 的 100 万亿 Tokens 实证研究"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-12-10T03:37:07.000Z">2025-12-10</time></p><p class="title"><a href="/Blog/2025/12/10/OpenRouter-%E7%9A%84-100-%E4%B8%87%E4%BA%BF-Tokens-%E5%AE%9E%E8%AF%81%E7%A0%94%E7%A9%B6/">OpenRouter 的 100 万亿 Tokens 实证研究</a></p><p class="categories"><a href="/Blog/categories/AI/">AI</a> / <a href="/Blog/categories/AI/Analytics/">Analytics</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/Blog/2025/12/03/TPU%20%E4%B8%8E%20GPU%20%E7%9A%84%E6%9C%AA%E6%9D%A5%E7%AB%9E%E4%BA%89%E6%A0%BC%E5%B1%80%E6%80%81%E5%8A%BF/"><img src="/Blog/gallery/GPU-TPU/tpu-vs-gpu.png" alt="TPU 与 GPU 的未来竞争格局态势"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-12-03T03:38:07.000Z">2025-12-03</time></p><p class="title"><a href="/Blog/2025/12/03/TPU%20%E4%B8%8E%20GPU%20%E7%9A%84%E6%9C%AA%E6%9D%A5%E7%AB%9E%E4%BA%89%E6%A0%BC%E5%B1%80%E6%80%81%E5%8A%BF/">TPU 与 GPU 的未来竞争格局态势</a></p><p class="categories"><a href="/Blog/categories/AI/">AI</a> / <a href="/Blog/categories/AI/Analytics/">Analytics</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/Blog/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/AI/Analytics/"><span class="level-start"><span class="level-item">Analytics</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/AI/Research/"><span class="level-start"><span class="level-item">Research</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/Blog/categories/AWS/"><span class="level-start"><span class="level-item">AWS</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/AWS/AWS-Certified-Generative-AI-Developer-Professional/"><span class="level-start"><span class="level-item">AWS Certified Generative AI Developer Professional</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/AWS/AWS-Certified-Machine-Learning-Specialty/"><span class="level-start"><span class="level-item">AWS Certified Machine Learning Specialty</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/AWS/AWS-Certified-Solution-Architect-Associate/"><span class="level-start"><span class="level-item">AWS Certified Solution Architect Associate</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/AWS/Architecture/"><span class="level-start"><span class="level-item">Architecture</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/AWS/Overview/"><span class="level-start"><span class="level-item">Overview</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/AWS/Serverless/"><span class="level-start"><span class="level-item">Serverless</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/Blog/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">9</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/Algorithm/Deep-Learning/"><span class="level-start"><span class="level-item">Deep Learning</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Algorithm/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Algorithm/NMF/"><span class="level-start"><span class="level-item">NMF</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Algorithm/Natural-Language-Processing/"><span class="level-start"><span class="level-item">Natural Language Processing</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Algorithm/Reinforce-Learning/"><span class="level-start"><span class="level-item">Reinforce Learning</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/Blog/categories/Big-Data/"><span class="level-start"><span class="level-item">Big Data</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/Big-Data/Spark/"><span class="level-start"><span class="level-item">Spark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/Blog/categories/Cloud-Native/"><span class="level-start"><span class="level-item">Cloud Native</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/Cloud-Native/Kubernetes/"><span class="level-start"><span class="level-item">Kubernetes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/Cloud-Native/Kubernetes/Knative/"><span class="level-start"><span class="level-item">Knative</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/Blog/categories/Development/"><span class="level-start"><span class="level-item">Development</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/Development/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Development/Full-Stack/"><span class="level-start"><span class="level-item">Full Stack</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Development/Log-Stack/"><span class="level-start"><span class="level-item">Log Stack</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Development/SQL/"><span class="level-start"><span class="level-item">SQL</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/Blog/categories/English-Study/"><span class="level-start"><span class="level-item">English Study</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Finance/"><span class="level-start"><span class="level-item">Finance</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/Finance/Asset-Management/"><span class="level-start"><span class="level-item">Asset Management</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Finance/Econometrics/"><span class="level-start"><span class="level-item">Econometrics</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/Blog/categories/LaTeX/"><span class="level-start"><span class="level-item">LaTeX</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Lifestyle/"><span class="level-start"><span class="level-item">Lifestyle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/Blog/categories/Terraform/"><span class="level-start"><span class="level-item">Terraform</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/Blog/categories/Terraform/Serverless/"><span class="level-start"><span class="level-item">Serverless</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/Blog/tags/AI/"><span class="tag">AI</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/AWS/"><span class="tag">AWS</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/AWS-Serverless/"><span class="tag">AWS - Serverless</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Apps/"><span class="tag">Apps</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/BERT/"><span class="tag">BERT</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/CNN/"><span class="tag">CNN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Certified/"><span class="tag">Certified</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Certified-Machine-Learning-Specialty/"><span class="tag">Certified Machine Learning - Specialty</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Cloud-Native-Kubernetes/"><span class="tag">Cloud Native - Kubernetes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Clustering/"><span class="tag">Clustering</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Coffee/"><span class="tag">Coffee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Deep-Learning/"><span class="tag">Deep Learning</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Deep-Learning/"><span class="tag">Deep-Learning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Django/"><span class="tag">Django</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/EKK/"><span class="tag">EKK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Econometrics/"><span class="tag">Econometrics</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/GPT-2/"><span class="tag">GPT-2</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/JetPack/"><span class="tag">JetPack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Knative/"><span class="tag">Knative</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Kotlin/"><span class="tag">Kotlin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/LaTeX/"><span class="tag">LaTeX</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Log/"><span class="tag">Log</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Machine-Learning/"><span class="tag">Machine-Learning</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/NLP/"><span class="tag">NLP</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/NMF/"><span class="tag">NMF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Overview-of-AWS/"><span class="tag">Overview of AWS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/PyTorch/"><span class="tag">PyTorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/React/"><span class="tag">React</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Reinforce-Learning/"><span class="tag">Reinforce Learning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Serverless/"><span class="tag">Serverless</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Serverless-Terraform/"><span class="tag">Serverless - Terraform</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Spark/"><span class="tag">Spark</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/TOEFL/"><span class="tag">TOEFL</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/Blog/tags/Word2Vec/"><span class="tag">Word2Vec</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/Blog/img/self.jpg" alt="Haojun(Vincent) Gao"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Haojun(Vincent) Gao</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/Blog/archives"><p class="title">53</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/Blog/categories"><p class="title">34</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/Blog/tags"><p class="title">37</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、智能体记忆亟需新的分类体系并回答关键问题"><span class="level-left"><span class="level-item">一、智能体记忆亟需新的分类体系并回答关键问题</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#LLM-智能体五类行动空间对照表"><span class="level-left"><span class="level-item">LLM 智能体五类行动空间对照表</span></span></a></li><li><a class="level is-mobile" href="#Agent-Memory-vs-LLM-Memory-vs-RAG-vs-Context-Engineering"><span class="level-left"><span class="level-item">Agent Memory vs. LLM Memory vs RAG vs Context Engineering</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#二、记忆的形式：词元级记忆，参数级记忆，以及隐空间记忆"><span class="level-left"><span class="level-item">二、记忆的形式：词元级记忆，参数级记忆，以及隐空间记忆</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-词元级记忆"><span class="level-left"><span class="level-item">2.1 词元级记忆</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-词元级记忆的三大类型"><span class="level-left"><span class="level-item">2.1.1 词元级记忆的三大类型</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-简单记忆（一维）"><span class="level-left"><span class="level-item">2.1.2 简单记忆（一维）</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-平面记忆（二维）"><span class="level-left"><span class="level-item">2.1.2 平面记忆（二维）</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-层次记忆（三维）"><span class="level-left"><span class="level-item">2.1.2 层次记忆（三维）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-参数化记忆"><span class="level-left"><span class="level-item">2.2 参数化记忆</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-内部参数化记忆"><span class="level-left"><span class="level-item">3.2.1 内部参数化记忆</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-外部参数化记忆"><span class="level-left"><span class="level-item">3.2.2 外部参数化记忆</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-3-隐式记忆"><span class="level-left"><span class="level-item">2.3 隐式记忆</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-3-1-生成"><span class="level-left"><span class="level-item">2.3.1 生成</span></span></a></li><li><a class="level is-mobile" href="#2-3-2-复用"><span class="level-left"><span class="level-item">2.3.2 复用</span></span></a></li><li><a class="level is-mobile" href="#2-3-3-转换"><span class="level-left"><span class="level-item">2.3.3 转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-4-适配性"><span class="level-left"><span class="level-item">2.4 适配性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、记忆的功能：智能体为何需要记忆？"><span class="level-left"><span class="level-item">三、记忆的功能：智能体为何需要记忆？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-事实记忆：持久的认知基础与清晰的外部事实"><span class="level-left"><span class="level-item">3.1 事实记忆：持久的认知基础与清晰的外部事实</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-用户事实记忆：持久的认知基础"><span class="level-left"><span class="level-item">3.1.1 用户事实记忆：持久的认知基础</span></span></a></li><li><a class="level is-mobile" href="#3-1-2-环境事实记忆：清晰的外部事实"><span class="level-left"><span class="level-item">3.1.2 环境事实记忆：清晰的外部事实</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-经验记忆：抽象与习得"><span class="level-left"><span class="level-item">3.2 经验记忆：抽象与习得</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-案例记忆：高级推理的基础模板"><span class="level-left"><span class="level-item">3.2.1 案例记忆：高级推理的基础模板</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-策略记忆：具备泛化能力的认知手脚架"><span class="level-left"><span class="level-item">3.2.2 策略记忆：具备泛化能力的认知手脚架</span></span></a></li><li><a class="level is-mobile" href="#3-2-3-技能记忆：认知进化的核心动力"><span class="level-left"><span class="level-item">3.2.3 技能记忆：认知进化的核心动力</span></span></a></li><li><a class="level is-mobile" href="#3-2-4-混合记忆：全面的认知架构"><span class="level-left"><span class="level-item">3.2.4 混合记忆：全面的认知架构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-工作记忆：主动压缩信息，锚定未来行动"><span class="level-left"><span class="level-item">3.3 工作记忆：主动压缩信息，锚定未来行动</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-单轮次工作记忆：主动压缩信息"><span class="level-left"><span class="level-item">3.3.1 单轮次工作记忆：主动压缩信息</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-多轮次工作记忆：锚定未来行动"><span class="level-left"><span class="level-item">3.3.2 多轮次工作记忆：锚定未来行动</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、记忆的动态：记忆是如何运行与演进？"><span class="level-left"><span class="level-item">四、记忆的动态：记忆是如何运行与演进？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-记忆的形成：从信息的简单压缩，到经验的长期拥有"><span class="level-left"><span class="level-item">4.1 记忆的形成：从信息的简单压缩，到经验的长期拥有</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-1-语义摘要：全局压缩"><span class="level-left"><span class="level-item">4.1.1 语义摘要：全局压缩</span></span></a></li><li><a class="level is-mobile" href="#4-1-2-知识蒸馏：提炼知识"><span class="level-left"><span class="level-item">4.1.2 知识蒸馏：提炼知识</span></span></a></li><li><a class="level is-mobile" href="#4-1-3-结构构建：捕捉复杂逻辑"><span class="level-left"><span class="level-item">4.1.3 结构构建：捕捉复杂逻辑</span></span></a></li><li><a class="level is-mobile" href="#4-1-4-隐式表征：机器原生"><span class="level-left"><span class="level-item">4.1.4 隐式表征：机器原生</span></span></a></li><li><a class="level is-mobile" href="#4-1-5-参数内化：拥有能力"><span class="level-left"><span class="level-item">4.1.5 参数内化：拥有能力</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-2-记忆的演化：一致且变化的认知与对人类的模拟"><span class="level-left"><span class="level-item">4.2 记忆的演化：一致且变化的认知与对人类的模拟</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-2-1-记忆整合：形成高级且完整的知识图景"><span class="level-left"><span class="level-item">4.2.1 记忆整合：形成高级且完整的知识图景</span></span></a></li><li><a class="level is-mobile" href="#4-2-2-记忆更新：始终保持一致的自我"><span class="level-left"><span class="level-item">4.2.2 记忆更新：始终保持一致的自我</span></span></a></li><li><a class="level is-mobile" href="#4-2-3-记忆遗忘：对人类记忆的模拟"><span class="level-left"><span class="level-item">4.2.3 记忆遗忘：对人类记忆的模拟</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-记忆检索"><span class="level-left"><span class="level-item">4.3 记忆检索</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-3-1-检索时机与意图"><span class="level-left"><span class="level-item">4.3.1 检索时机与意图</span></span></a></li><li><a class="level is-mobile" href="#4-3-2-查询构建"><span class="level-left"><span class="level-item">4.3.2 查询构建</span></span></a></li><li><a class="level is-mobile" href="#4-3-3-检索策略"><span class="level-left"><span class="level-item">4.3.3 检索策略</span></span></a></li><li><a class="level is-mobile" href="#4-3-4-检索后处理"><span class="level-left"><span class="level-item">4.3.4 检索后处理</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#五、新兴前沿"><span class="level-left"><span class="level-item">五、新兴前沿</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-记忆检索与记忆生成"><span class="level-left"><span class="level-item">5.1 记忆检索与记忆生成</span></span></a></li><li><a class="level is-mobile" href="#5-2-自动化记忆管理：从人工设计到自主构建的记忆系统"><span class="level-left"><span class="level-item">5.2 自动化记忆管理：从人工设计到自主构建的记忆系统</span></span></a></li><li><a class="level is-mobile" href="#5-3-强化学习与智能体记忆的结合：强化学习正在让智能体内化记忆管理能力"><span class="level-left"><span class="level-item">5.3 强化学习与智能体记忆的结合：强化学习正在让智能体内化记忆管理能力</span></span></a></li><li><a class="level is-mobile" href="#5-4-多模态记忆"><span class="level-left"><span class="level-item">5.4 多模态记忆</span></span></a></li><li><a class="level is-mobile" href="#5-5-多智能体系统中的共享记忆：从孤立记忆到共享认知基底"><span class="level-left"><span class="level-item">5.5 多智能体系统中的共享记忆：从孤立记忆到共享认知基底</span></span></a></li><li><a class="level is-mobile" href="#5-6-面向世界模型的记忆机制"><span class="level-left"><span class="level-item">5.6 面向世界模型的记忆机制</span></span></a></li><li><a class="level is-mobile" href="#5-7-可信记忆：从可信检索增强生成到可信记忆"><span class="level-left"><span class="level-item">5.7 可信记忆：从可信检索增强生成到可信记忆</span></span></a></li><li><a class="level is-mobile" href="#5-8-与人类认知的关联"><span class="level-left"><span class="level-item">5.8 与人类认知的关联</span></span></a></li></ul></li><li><a class="level is-mobile" href="#六、结论：形式、功能与动态机制"><span class="level-left"><span class="level-item">六、结论：形式、功能与动态机制</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/Blog/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/Blog/"><img src="/Blog/img/logo.jpg" alt="Gao Haojun" height="28"></a><p class="is-size-7"><span>&copy; 2026 Haojun(Vincent) Gao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Gallery" href="https://www.gaohaojun.com/"><i class="fab fa-fighter-jet"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Linkedin" href="https://www.instagram.com/vincent_gaohj/"><i class="fab fa-linkedin"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/vincent_gaohj/"><i class="fab fa-instagram"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/VincentGaoHJ"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/Blog/js/column.js"></script><script src="/Blog/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/Blog/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script src="/Blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/Blog/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/Blog/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>